/**
 * File:
 *      include/bootloader/generic/global_options_widget.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Widget for configuring global boot options
 *
 * Authors:
 *      Joachim Plack <jplack@suse.de>
 *
 * $Id$
 *
 */


{
textdomain "bootloader";

import "BootCommon";

include "bootloader/generic/widget_funcs.ycp";


/**
 * option cache and reader function
 */
map<string,any> _gow_options = nil;

map<string,any> GOW_options () {
    // HACK add checkbox for enabling trusted GRUB
    if (BootCommon::getLoaderType (false) == "grub")
    {
    	BootCommon::global_options["trusted_grub"] = "bool:Use Trusted Grub:true";
    } else {
	if (haskey(BootCommon::global_options, "trusted_grub"))
	   BootCommon::global_options = remove(BootCommon::global_options, "trusted_grub");
    }
    // HACK delete fallback and former_default_image_flavor
    if (haskey(BootCommon::global_options, "former_default_image_flavor"))
	BootCommon::global_options = remove(BootCommon::global_options, "former_default_image_flavor");

    if (haskey(BootCommon::global_options, "fallback"))
	BootCommon::global_options = remove(BootCommon::global_options, "fallback");

    if ( _gow_options == nil)
    {
	_gow_options = filter( string key, any value, BootCommon::global_options, {
	    return key != "boot" && key != "default" && substring(key,0,5) != "boot_";
	});
    }
    return _gow_options;
}


/**
 * Init function of widget
 * @param widget string id of the widget
 */
void GOW_Init (string widget) {
    generic_Init(widget, GOW_options(), BootCommon::globals);
}


/**
 * Store function of a widget
 * @param widget string widget key
 * @param event map event that caused the operation
 */
void GOW_Store (string widget, map event) {
    generic_Store(widget, event, GOW_options(), _globals_store_data);
}


/**
 * Handle function of a widget
 * @param key any widget key
 * @param event map event description of event that occured
 * @return symbol always nil
 */
symbol GOW_Handle (string key, map event) {
    y2milestone("Called for key %1 through event %2", key, event);
    // FIXME: is that the right way? "path" widget managed right?
    // bnc #461613 - Unable to boot after making changes to boot loader
    // bnc #357290 - module rewrites grub generic code when leaving with no changes, which may corrupt grub
    if (event["EventReason"]:"" == "ValueChanged")
        BootCommon::location_changed = true;
    return generic_Handle (key, event);
}


/**
 * Validate function of a widget
 * @param widget string widget key
 * @param event map event that caused validation
 * @return boolean true if validation succeeded
 */
boolean GOW_Validate (string widget, map event){
    y2milestone("Called from widget %1 through event %2", widget, event);
    // FIXME: here we need a callback to the architcture specific perl interface
    return generic_Validate(widget, event, GOW_options(), _globals_store_data);
}


/**
 * Build a map describing a widget
 * @return a map describing a widget
 */
map<string,any> genericGlobalBootOptionWidget () {
    // construct widget from information about global options
    map<string,any> options = GOW_options();
    term widget = nil;
    string help = nil;
    if (size(options) > 12)
    {
        map<string,any> gt_map1 = $[];
        map<string,any> gt_map2 = $[];
        foreach(string s, any a, options, {
          if (size(gt_map1) > size(gt_map2))
               gt_map2[s] = a;
          else
               gt_map1[s] = a;
        });
        gt_map1 = generic_Term(gt_map1, "normal");
        gt_map2 = generic_Term(gt_map2, "normal");
        widget = `Frame (_("Boot Menu"), `HBox (
	    `HSpacing (2),
	    gt_map1["term"]:nil,
	    `HSpacing (2),
	    gt_map2["term"]:nil,
	    `HSpacing (2)
	));
        help = (string)gt_map1["help"]:"" + (string)gt_map2["help"]:"";
    }
    else
    {
        map<string,any> gt_map = generic_Term(options, "normal");
	if (!haskey(gt_map, "term")) {
            y2milestone("genericGlobalBootOptionWidget: Trying to generate empty widget");
	    return nil;
        }

	widget = `Frame (_("Boot Menu"), `HBox (
	    `HSpacing (2),
	    gt_map["term"]:nil,
	    `HSpacing (2)
	));
        help = (string)gt_map["help"]:"";
    }

    return $[
	"widget" : `custom,
	// frame
	"custom_widget" : widget,
	"init" : GOW_Init,
	"store" : GOW_Store,
	"handle" : GOW_Handle,
	// "handle_events" : gt_map["events"]:[],
	"validate_type" : `function,
	"validate_function" : GOW_Validate,
	"help" : generic_Help("boot-menu") + help,
    ];
}

} // include end
