/**
 * File:
 *      modules/BootCommon.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Data to be shared between common and bootloader-specific parts of
 *      bootloader configurator/installator, generic versions of bootloader
 *      specific functions
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *      Joachim Plack <jplack@suse.de>
 *      Olaf Dabrunz <od@suse.de>
 *
 * $Id$
 *
 */

{
module "BootCommon";

textdomain "bootloader";

import "Arch";
import "GfxMenu";
import "HTML";
import "Mode";
import "PackageSystem";
import "Storage";
import "String";
import "Pkg";
import "Popup";
import "Package";
import "PackagesProposal";

import "Kernel";

import "Linuxrc";


// General bootloader settings

/**
 * map of global options and types for new perl-Bootloader interface
 */
global map<string,any> global_options = $[];

/**
 * map of section options and types for new perl-Bootloader interface
 */
global map<string,any> section_options = $[];

/**
 * map of other exported information for new perl-Bootloader interface
 */
global map<string,any> exports = $[];


/**
 * boolean value indicate if "/" is on logical
 * and primary /boot doesn't exist
 */

global boolean boot_device_on_logical = false;

/**
 * map of global options and values
 */
global map<string,string> globals = $[];

/**
 * list of section
 */
global list<map<string,any> > sections = [];

/**
 * Saved change time from target map - proposal
 */

global integer cached_settings_base_data_change_time = nil;

/**
 * Saved change time from target map - only for MapAllPartitions()
 */

global integer saved_last_change_time_from_storage = nil;



/**
 * device mapping between Linux and firmware
 */
global map<string,string> device_mapping = $[];

/**
 * device mapping between real devices and multipath
 */
global map<string,string> multipath_mapping = $[];

// it is ugly hack because y2-storage doesn't known to indicate
// that it finish (create partitions) proposed partitioning
// of disk in installation
/** bnc#687878 - mountby uuid not respected in menu.lst
 * Indicate if storage already finish partitioning of disk 
 * if some partition includes any keyword "create"
 * the value is the first found partition with flag "create" e.g. /dev/sda2
 * empty string means all partitions are created
 */
string proposed_partition = "";

/** bnc#687878 - mountby uuid not respected in menu.lst
 * 0 - if all devices in variable all_devices are created.
 * 1 - if partition with flag "create" was found in MapDevices()
 * 2 - if proposed_partition was created or flag "create" was deleted
 * by y2-storage. the value is set in CheckProposedPartition ()
 */
integer all_devices_created = 0;

/** bnc#687878 - mountby uuid not respected in menu.lst
 * 0 - if all devices in variable all_partitions and all_disks are created
 * 1 - if partition with flag "create" was found in MapDevices()
 * 2 - if proposed_partition was created or flag "create" was deleted
 * by y2-storage. the value is set in CheckProposedPartition ()
 */
integer all_partitions_created = 0;

/**
 * Flag indicates that bios_id_missing in disk 
 * true if missing false if at least one disk has bios_id
 */

global boolean bois_id_missing = true;

/**
 * device to save loader stage 1 to
 * NOTE: this variable is being phased out. The boot_* keys in the globals map
 * are now used to remember the selected boot location. Thus, we now have a
 * list of selected loader devices. It can be generated from the information in
 * the boot_* keys and the global variables (Boot|Root|Extended)PartitionDevice
 * and mbrDisk by calling GetBootloaderDevices().
 */
global string loader_device = nil;

/**
 * Embed stage 1.5 of the bootloader to dedicated area (if supported)?
 * This is currently only supported by GRUB. A stage 1.5 can be put into the
 * area after the MBR (into the rest of the very first cylinder) or into the
 * "boot loader area" of some filesystems such as FFS and ReiserFS. For more
 * information, see the grub documentation, esp.
 *	"info '(grub.info.gz)Bootstrap tricks'"
 *	"info '(grub.info.gz)Images'"
 * FIXME: phase this variable out. It is not used any more. GRUB stages are now
 * installed with the "setup" command that handles embed_stage15 internally.
 */
// This needs to be defined here so that various files can include it.
// BootCommon.ycp is currently the only central include file, separate include
// files that are central and specific to each bootloader do not exist (yet?).
global boolean embed_stage15 = true;



// proposal helping variables

/**
 * The kind of bootloader location that the user selected last time he went to
 * the dialog. Used as a hint next time a proposal is requested, so the
 * proposal can try to satisfy the user's previous preference.
 * NOTE: this variable is being phased out. The boot_* keys in the globals map
 * will be used to remember the last selected location.
 * Currently, valid values are: mbr, boot, root, floppy, mbr_md, none
 */
global string selected_location = nil;



/* These global variables and functions are needed in included files */

/**
  * string representing device name of /boot partition
  * same as RootPartitionDevice if no separate /boot partition
  */
global string BootPartitionDevice = "";


/**
  * string representing device name of /boot/efi partition, if any
  */
global string BootEFIPartitionDevice = "";


/**
  * string representing device name of / partition
  */
global string RootPartitionDevice = "";

/**
  * string representing device name of extended partition
  */
global string ExtendedPartitionDevice = "";

/**
  * Parameters of currently used bootloader
  */
global map<string, any> current_bootloader_attribs = $[];

/**
  * Parameters of all bootloaders
  */
global map<string,map<string, any> > bootloader_attribs = $[];

/**
  * Name of currently edited section
  */
global string current_section_name = nil;

/**
 * Index of current section, -1 for new created section
 */
global integer current_section_index = -1;

/**
  * Curtrently edited section -- tmp store
  */
global map<string,any> current_section = $[];


/**
  * list of installed floppy devices
  */
global list<string> floppy_devices = nil;

/** FATE#305008: Failover boot configurations for md arrays with redundancy
 * list <string> includes physical disks used for md raid
 */

global list <string> md_physical_disks = [];

/**
  * Option types for different bootloaders
  */
global map<string,map<string,string> > opt_types = $[];

/**
  * device holding MBR for bootloader
  */
global string mbrDisk = "";

/**
  * was currently edited section changed (== true)
  */
global boolean one_section_changed = false;

/**
  * Backup original MBR before installing bootloader
  */
global boolean backup_mbr = false;

/**
 * true if default section is edited
 * it is important for remember default name...
 */
global boolean default_changed = false;

/**
  * Activate bootloader partition during installation?
  */
global boolean activate = false;


/** FATE #303548 - Grub: limit device.map to devices detected by BIOS
  * Ask user if he wants to edit again bootloader settings
  * It is used if device.map is limited and "boot" disk is out of range 
  * The range is the first 8 devices
  */
global boolean ask_user = false;

/**
  * Replace MBR with generic code after bootloader installation?
  */
global boolean repl_mbr = false;

/**
  * Kernel parameters at previous detection
  */
global string kernelCmdLine = "";

/**
  * were settings changed (== true)
  */
global boolean changed = false;


global map<string,any> installed_version = $[];
global map<string,any> update_version = $[];

global map<string,string> edited_files = $[];
// common variables

/**
  * type of bootloader to configure/being configured
  * shall be one of "lilo", "grub", "silo", "milo", "aboot",
  * "elilo", "ppc", "zipl", "mips"
  */
string loader_type = nil;

// sysconfig variables

// installation proposal help variables

/**
  * Last detection proposed to prefer lilo instead of grub
  */
global boolean prefer_lilo = false;

/**
  * List of partitions deleted in primary proposal
  */
global list<string> del_parts = [];

// variables for storing data

// saving mode setting functions

/**
  * map of save mode settings
  */
global map write_settings = $[];

// summary dialog state

/**
  * Show verbose summary output
  */
global boolean verbose = false;

// ui help variables


string additional_failsafe_params = "";


// other variables

/**
  * Settings of other bootloaders used when switching bootloader
  */
global map other_bl = $[];

// bootloader installation variables

/**
  * Was the activate flag changed by user?
  */
global boolean activate_changed = false;
/**
  * Save everything, not only changed settings
  */
global boolean save_all = false;

// state variables

/**
  * was the propose function called (== true)
  */
global boolean was_proposed = false;
/**
  * Were module settings read (== true)
  */
global boolean was_read = false;
/**
  * were sections settings changes (== true)
  */
global boolean sections_changed = false;
/**
  * Was bootloader location changed? (== true)
  */
global boolean location_changed = false;
/**
  * Were configuration files manually edited and chamged?
  */
global boolean files_edited = false;
/**
  * Has been files edited warning already shown?
  */
global boolean files_edited_warned = false;
/**
  * Shall be settings saved when finishing bootloader configuration?
  */
global boolean save_on_finish = true;
/**
  * time of last change of partitioning
  */
global integer partitioning_last_change = 0;
/**
 * true if memtest was removed by user (manually) during the installation
 * proposal
 */
global list<string> removed_sections = [];

/**
 * The name of the default section as it was read
 */
global string read_default_section_name = "";

/**
 * Types of sections that should be updated (changed device names)
 */
 // FIXME: see FIXME in lilolike.ycp:899
global list<string> update_section_types = [ "floppy", "other" ];
//    = [ "linux", "failsafe", "initrd", "floppy" ];

/**
 * List of all supported bootloaders
 */
global list<string> bootloaders = ["lilo", "grub", "elilo", "milo", "silo",
				   "aboot", "zipl", "ppc", "mips"];

/** FATE#305008: Failover boot configurations for md arrays with redundancy
 * if true enable redundancy for md array
 */
global boolean enable_md_array_redundancy = true;

/**
 * bnc #468922 - problem with longtime running the parsing a huge number of disks
 * map<string,map> the map of all partitions with info about it -> 
 * necessary for Dev2MountByDev() in routines/misc.ycp 
 */
global map<string,map> all_partitions = $[];

/**
 * bnc #468922 - problem with longtime running the parsing a huge number of disks
 * map<string,map> target map try to minimalize calling Storage::GetTargetMap()
 *
 */ 
map<string,map> target_map = $[];

global define string getLoaderType (boolean recheck);
global define list<string> getBootloaders ();
global define list<string> Summary ();
global define boolean UsingXenPae();
global map<string,any> CreateLinuxSection (string title);
global string UpdateSerialConsole (string append, string console);
global string addMDSettingsToGlobals ();
global boolean VerifyMDArray ();

// zipl.conf has its own idiosyncrasies when it comes to default entries
global string checkZiplDefault (string def);

//
// FIXME: the select and selectdevice seem to be broken: the default value of
// the widget description string needs to be patched with the current value of
// the widget
//
global void change_widget_default_value (string itemname, string defaultvalue) {
    // Put defaultvalue as default value into widget description item like
    // "boot_{chrp,prep,iseries,...}_custom" or "boot_custom".
    // Examples:
    // "select:PReP or FAT partition::/dev/sda1:/dev/sda3:/dev/sdb1:/dev/sdd1" ->
    // "select:PReP or FAT partition:/dev/sda3:/dev/sda1:/dev/sda3:/dev/sdb1:/dev/sdd1"
    //
    // "selectdevice:Custom Boot Partition::/dev/sda3" ->
    // "selectdevice:Custom Boot Partition:/dev/sda3:/dev/sda3"
    string old_description = global_options[itemname]:"";
    global_options[itemname] =
	regexpsub( old_description, "^([^:]*:[^:]*:).*$", "\\1") +
	defaultvalue +
	regexpsub( old_description, "^[^:]*:[^:]*:[^:]*(:.*)$", "\\1");
}


/*
 * help message and dscription definitions
 */
include "bootloader/generic/helps.ycp";

include "bootloader/routines/popups.ycp";
include "bootloader/routines/misc.ycp";
// FIXME: there are other archs than i386, this is not 'commmon'
include "bootloader/routines/lilolike.ycp";
include "bootloader/routines/lib_iface.ycp";

// interface to bootloader library

// FIXME 2x functions should not be finally here...
/**
 * Check whether XEN is selected for installation resp. selected
 * @return boolean true of XEN installed/selected
 */
global boolean XenPresent () {
    boolean ret = (! contains (removed_sections, "xen"))
	&& (Mode::test ()
	    || (Mode::normal () && Pkg::IsProvided ("xen")
		&& Pkg::IsProvided ("kernel-xen"))
	    || (! Mode::normal () && Pkg::IsSelected ("xen")
		&& Pkg::IsSelected ("kernel-xen"))
	    || UsingXenPae());

    y2milestone("ret: %1", ret);
    return ret;
}

global boolean UsingXenPae() {
    if (Mode::test())
	return true;
    if (Mode::normal())
        return Pkg::IsProvided ("kernel-xenpae");
    return Pkg::IsSelected ("kernel-xenpae");
}

/**
 * Function check if trusted grub is selected
 * or installed return true if is selected/installed
 * and add trusted_grub to globals
 * @return boolean true if trusted grub is selected/installed
 */

global boolean isTrustedGrub ()
{
    boolean ret = false;
    if (Mode::normal ())
    {
	if (Pkg::IsProvided ("trustedgrub") || Package::Installed("trustedgrub"))
	{
	    ret = true;
	    globals["trusted_grub"] = "true";
	}

    } else {
	if (Pkg::IsSelected ("trustedgrub"))
	{
	    ret = true;
	    globals["trusted_grub"] = "true";
	}
    }
    return ret;
}


/**
 * Get the size of memory for XEN's domain 0
 * @return the memory size in kB
 */
global integer Dom0MemorySize () {
    list<map> memory = (list<map>) SCR::Read(.probe.memory);

    y2milestone("memory: %1", memory);
    integer memory_size = 0;

    foreach(map info, memory, {
            // internal class, main memory
            if (info["class_id"]:0 == 257 && info["sub_class_id"]:0 == 2)
            {
                list<map> minf = info["resource", "phys_mem"]:[];
                foreach(map i, minf, {
                        memory_size = memory_size + i["range"]:0;
                    }
                );
            }
        }
    );
    // size in kB lowered 64 MB for XEN itself
    memory_size = memory_size / 1024 - (64 * 1024);
    y2milestone ("Memory size for XEN domain 0: %1", memory_size);
    return memory_size;
}


/**
 * Create section for linux kernel
 * @param title string the section name to create (untranslated)
 * @return a map describing the section
 */
global map<string,any> CreateLinuxSection (string title) {
    map<string,any> ret = $[
	"name" : translateSectionTitle (title),
	"original_name" : title,
	"type" : "image",
	"__auto" : true,
	"__changed" : true,
    ];

    if (title == "memtest86") {
	if (MemtestPresent ()) {
	    ret["kernel"] = "/boot/memtest.bin";
	    ret["__devs"] = [BootCommon::BootPartitionDevice];
	    return ret;
	}
	else {
	    return $[];
	}
    }

    string resume = BootArch::ResumeAvailable ()
	? getLargestSwapPartition ()
	: "";
    // try to use label or udev id for device name... FATE #302219
    if ((resume != "") && (resume != nil))
	resume = Dev2MountByDev(resume);


    // FIXME:
    // This only works in the installed system (problem with GetFinalKernel()),
    // in all other cases we use the symlinks.

    string kernel_fn = "";
    string initrd_fn = "";

    if (Mode::normal ()) {
	// Find out the file names of the "real" kernel and initrd files, with
	// version etc. pp. whatever (currently version-flavor) attached.
	// FIXME: also do this for xen and xenpae kernels as found below
	//
	// Note: originally, we wanted to find out the kernel file names during
	// installation proposal when the files are not yet installed. But not
	// all the necessary interfaces work at that time. Now, this variant is
	// only run in the "running system", and could as well look at the
	// installed files.
	//

	// First of all, we have to initialize the RPM database
	Pkg::TargetInit ( "/",	// installed system
		false );	// don't create a new RPM database

	// Then, get the file names in the "selected" kernel package,
	// the kernel file is actually in kernel-*-base meanwhile
	string kernel_package = Kernel::ComputePackage() + "-base";
	list<string> files = Pkg::PkgGetFilelist( kernel_package, `installed );
	y2milestone ("kernel package %1 has these files: %2", kernel_package, files);

	// then find the first file that matches the arch-dependent kernel file
	// name prefix and the initrd filename prefix.
	string kernel_prefix = "/boot/" + Kernel::GetBinary ();
	string initrd_prefix = "/boot/initrd";

	list<string> files_filtered = filter (string file, files, {
	    return ( substring(file, 0, size(kernel_prefix)) == kernel_prefix );
	});


	// Sort the filtered files, thus the image strings by length, the big ones
	// at the beginning, the small ones at the end of the list.
	// So, the first element of the sorted list files_filtered is the image string
	// containing the version and flavor.
	files_filtered = sort ( string kbig, string ksmall, files_filtered, ``(
		size(kbig) > size(ksmall) ) );

	kernel_fn = (
	    title == "wildcard" ?
		"/boot/" + Kernel::GetBinary () + "-*" :
		files_filtered[0]:""
	);

	files_filtered = filter (string file, files, {
	    return substring(file, 0, size(initrd_prefix)) == initrd_prefix && !regexpmatch(file, "-kdump$");
	});

	// Sort the filtered files, thus the initrd strings by length, the big ones
	// at the beginning, the small ones at the end of the list.
	// So, the first element of the sorted list files_filtered is the initrd string
	// containing the version and flavor.
	files_filtered = sort ( string ibig, string ismall, files_filtered, ``(
		size(ibig) > size(ismall) ) );

	initrd_fn = (
	    title == "wildcard" ?
		"/boot/initrd-*" :
		files_filtered[0]:""
	);

	if ((kernel_fn == "") || (kernel_fn == nil))
	    kernel_fn = "/boot/vmlinuz";

	if ((initrd_fn == "") || (initrd_fn == nil))
	    initrd_fn = "/boot/initrd";

	// read commandline options for kernel
	list<string> cmd = (list<string>) SCR::Read(.proc.cmdline);

  	any vga = nil; 

	// trying to find "vga" option
  	foreach ( string key, cmd, 
	{
    	    if (find(key, "vga=") != -1)
      		vga = key;
    	    y2milestone("key: %1", key);
  	});
	y2milestone("vga from command line: %1", vga);
  	list <string> mode =[];

	// split vga=value
  	if ((vga != nil) && (vga != ""))
      	    mode = splitstring(tostring(vga), "=");

	string vgamode =nil;

	// take value if exist
	if ((size(mode)>1) && (mode[0]:"" == "vga"))
     	    vgamode = mode[1]:nil;

	// add value of vga into proposal (if exist)
	if ((vgamode != nil) && (vgamode != ""))
	{
	    ret["vga"] = vgamode;
	    y2milestone("vga mode: %1", vgamode);
	}

    } else {
	// the links are shown in the proposal; at the end of an installation,
	// in bootloader_finish, they will be resolved to the real filenames
	kernel_fn = "/boot/" + Kernel::GetBinary ()
	    + (title == "wildcard" ? "-*" : "");
	initrd_fn = "/boot/initrd" + (title == "wildcard" ? "-*" : "");
    }
    // done: kernel_fn and initrd_fn are the results
    y2milestone ("kernel_fn: %1 initrd_fn: %2", kernel_fn, initrd_fn);

    ret = (map <string, any>)union (ret, $[
	"image" : kernel_fn,
	"initrd" : initrd_fn,
	// try to use label or udev id for device name... FATE #302219
	"root" : Dev2MountByDev(RootPartitionDevice),
	"append" : (title == "failsafe")
	    ? BootArch::FailsafeKernelParams ()
	    : BootArch::DefaultKernelParams (resume),
	"__devs" : [BootPartitionDevice, RootPartitionDevice],
    ]);
    if (BootArch::VgaAvailable () && Kernel::GetVgaType () != "")
    {

	// B#352020 kokso: - Graphical failsafe mode
	//if (title == "failsafe")
	//    ret["vga"] = "normal";
	//else
	ret["vga"] = Kernel::GetVgaType ();

	// B#352020 end

    }
    if (title == "xen")
    {
        ret["type"] = "xen";
	ret["xen_append"] = "";

	// bug #400526 there is not xenpae anymore...
	ret["xen"] = "/boot/xen.gz";
	ret["image"] = "/boot/" + Kernel::GetBinary () + "-xen";
	ret["initrd"] = "/boot/initrd-xen";

    }
    else if (title == "wildcard")
    {
	ret["wildcard"] = kernel_fn;
	ret["name"] = "*";
    }
    return ret;
}

// generic versions of bootloader-specific functions

/**
  * Export bootloader settings to a map
  * @return bootloader settings
  */
global define map Export () {
    MapDevices();
    map exp = $[
	"global": remapGlobals(globals),
	"sections" : remapSections(sections),
	"device_map" : remapDeviceMap(device_mapping),
    ];
    if ( ! ( loader_type == "grub" ) ) {
	exp["repl_mbr"] = repl_mbr;
	exp["activate"] = activate;
    }

    return exp;
}

/**
  * Import settings from a map
  * @param settings map of bootloader settings
  * @return boolean true on success
  */
global define boolean Import (map settings) {
    globals = settings["global"]:$[];
    sections = importSections(settings["sections"]:[]);

    // FIXME: for grub, repl_mbr is replaced by globals["generic_mbr"]; same
    // for activate; remove the following when no bootloader uses these
    // variables any more
    if ( ! ( loader_type == "grub" ) ) {
	repl_mbr = settings["repl_mbr"]:false;
	activate = settings["activate"]:false;
    }
    device_mapping = settings["device_map"]:$[];
    return true;
}

/**
 * Read settings from disk
 * @param reread boolean true to force reread settings from system
 * @param avoid_reading_device_map do not read new device map from file, use
 * internal data
 * @return boolean true on success
 */
global boolean Read (boolean reread, boolean avoid_reading_device_map) {
    string bl = getLoaderType (false);
    if (bl == "none")
	return true;
    InitializeLibrary (reread, bl);
    if (reread)
    {
	BootCommon::ReadFiles (avoid_reading_device_map);
    }
    sections = GetSections ();
    globals = GetGlobal ();
    isTrustedGrub ();
    device_mapping = GetDeviceMap ();
    read_default_section_name = "";
    foreach (map<string,any> s, sections, {
	if (s["original_name"]:"" == "linux"
	    && read_default_section_name == "")
	{
	    read_default_section_name = s["name"]:"";
	}
    });

    // convert device names in device map to the kernel device names
    device_mapping = mapmap (string k , string v, device_mapping, {
	    // if we update from version 9 (SLES9), first convert old-style persistent
	    // device names to new-style persistent device names ("p1" -> "-part1")
	    // NOTE: this is idempotent; but other device name translation
	    // (e.g. libata migration) is not, so it will be done later
	    if (Mode::update () && installed_version["major"]:0 == 9) {
		k = Storage::SLES9PersistentDevNames(k);
		y2milestone( "devmap: dev name after SLES9 persistent dev name translation: %1", k);
	    }
	    return $[Dev2MountByDev(k) : v];
    });

    // convert custom boot device names in globals to the kernel device names
    // also, for legacy bootloaders like LILO that still pass device names,
    // convert the stage1_dev
    globals = mapmap (string k , string v, globals, {
	if ( k == "stage1_dev" || regexpmatch(k, "^boot_.*custom$" ) ) {
	    // see comments above
	    if (Mode::update () && installed_version["major"]:0 == 9) {
		v = Storage::SLES9PersistentDevNames(v);
		y2milestone( "globals: dev name after SLES9 persistent dev name translation: %1", v);
	    }
	    return $[k : Dev2MountByDev(v)];
	} else {
	    return $[k : v];
	}
    });


    // convert root device names in sections to kernel device names, if
    // possible
    sections = maplist (map<string,any> s, sections, {
	string rdev = s["root"]:"";
	// see comments above
	if (Mode::update () && installed_version["major"]:0 == 9) {
	    rdev = Storage::SLES9PersistentDevNames(rdev);
	    y2milestone( "sections: dev name after SLES9 persistent dev name translation: %1", rdev);
	}
	s["root"] = Dev2MountByDev(rdev);
	return s;
    });
    return true;
}

/**
  * Reset bootloader settings
  * @param init boolean true to repropose also device map
  */
global define void Reset (boolean init) {
    sections = [];
    globals = $[];
    // DetectDisks ();
    repl_mbr = false;
    activate = false;
    activate_changed = false;
    removed_sections = [];
    was_proposed = false;
    if (init)
    {
	ProposeDeviceMap ();
    }
}

/**
 * Propose bootloader settings
 */
global void Propose () {
    y2error ("No generic propose function available");
}

/** bnc#602743c#10 - YaST2 always writes 42 as baudrate in /etc/inittab
 * Check if console is defined in installation args
 *
 * @return boolean true if console is defined in Kernel::GetCmdLine ()
 */
boolean checkKernelCmdForConsole()
{
    boolean ret = false;
    if (Mode::installation())
    {
	string kernel_cmd = Kernel::GetCmdLine ();
	if (search(tolower(kernel_cmd), "console=") != nil)
	{
	    ret = true;
	    y2milestone("Remove gfxmenu -> it is added like installation arg: %1", kernel_cmd);
	}

    }
    return ret;
}

/** bnc# 346576,568295 - Bootloader configuration doesn't work for serial output
 * Function check if settings need to remove gfxmenu
 *
 * @return boolean - true if gfxmenu needs to be removed
 */

boolean removeGFXMenu ()
{
    if ((globals["trusted_grub"]:"" == "true") && (haskey(globals, "gfxmenu")))
    {
	y2milestone("Remove gfxmenu -> selected trusted grub");
	return true;
    }

    if ((globals["serial"]:nil != "") && (globals["serial"]:nil != nil) && (haskey(globals, "gfxmenu")))
    {
	y2milestone("Remove gfxmenu -> defined serial console");
	return true;
    }
    // bnc#602743c#10 - YaST2 always writes 42 as baudrate in /etc/inittab
    if (checkKernelCmdForConsole() && haskey(globals, "gfxmenu"))
	return true;

    if ((globals["gfxmenu"]:"" == "none") && (haskey(globals, "gfxmenu")))
    {
	y2milestone("Remove gfxmenu -> disabled gfxmenu");
	return true;
    }

    return false;
}

/**
 * Save all bootloader configuration files to the cache of the PlugLib
 * PlugLib must be initialized properly !!!
 * @param clean boolean true if settings should be cleaned up (checking their
 *  correctness, supposing all files are on the disk)
 * @param init boolean true to init the library
 * @param flush boolean true to flush settings to the disk
 * @return boolean true if success
 */
global boolean Save (boolean clean, boolean init, boolean flush) {
    if (clean)
    {
	BootCommon::RemoveUnexistentSections ("", "");
	// BootCommon::UpdateInitrdLine ();
	BootCommon::UpdateAppend ();
	BootCommon::UpdateGfxMenu ();
    }

    boolean ret = true;

    string bl = getLoaderType (false);

    InitializeLibrary (init, bl);

    if (bl == "none")
	return true;

    // FATE: #110038: Serial console
    // check and add console key with value for sections 
    addConsole();

    // bnc#583334 deleting boot message in yast2 while installing has no effect
    // add 'none' string instead of boot message take care about deleting
    if (removeGFXMenu())
	globals = remove(globals, "gfxmenu");

    // FIXME: give mountby information to perl-Bootloader (or define some
    // better interface), so that perl-Bootloader can use mountby device names
    // for these devices instead. Tracked in bug #248162.

    // convert custom boot device names in globals to the device names
    // indicated by "mountby"
    // also, for legacy bootloaders like LILO that still pass device names,
    // convert the stage1_dev
    map<string,string> my_globals = mapmap (string k , string v, globals, {
	if ((k == "stage1_dev") || (regexpmatch(k, "^boot_.*custom$" )) || (k == "boot_chrp_custom"))
	    //return $[k : BootCommon::Dev2MountByDev(v)];
	    return $[k : BootCommon::Dev2MountByDev(v)];
	else
	    return $[k : v];
    });

    // convert device names in device map to the device names indicated by
    // "mountby"

    y2milestone ("device map before mapping %1", device_mapping);
    map<string,string> my_device_mapping =
	mapmap (string k , string v, device_mapping, {
	    //return $[BootCommon::Dev2MountByDev(k) : v];
	    return $[BootCommon::Dev2MountByDev(k) : v];
    });
    y2milestone ("device map after mapping %1", my_device_mapping);

    // convert XEN section to linux section id running in domU
    // bnc #436899
    ConvertXENinDomU ();

    if (VerifyMDArray())
    {
	if ((enable_md_array_redundancy != true) && (haskey(my_globals, "boot_md_mbr")))
	    my_globals = remove(my_globals, "boot_md_mbr");
	 if ((enable_md_array_redundancy == true ) && (!haskey(my_globals, "boot_md_mbr")))
	    my_globals["boot_md_mbr"] = BootCommon::addMDSettingsToGlobals();

    } else {
	if (haskey(globals, "boot_md_mbr"))
	    my_globals = remove(my_globals, "boot_md_mbr");
    }

    ret = ret && DefineMultipath(multipath_mapping);
    ret = ret && SetDeviceMap (my_device_mapping);
    ret = ret && SetSections (sections);
    ret = ret && SetGlobal (my_globals);
    if (flush)
    {
	ret = ret && CommitSettings ();
    }

    // write settings to /etc/sysconfig/bootloader
    WriteToSysconf(false);	

    return ret;
}
    /**
      * Display bootloader summary
      * @return a list of summary lines
      */
    global define list<string> Summary () {
	if (getLoaderType (false) == "none")
	{
	    return [HTML::Colorize (
		getLoaderName (getLoaderType (false), `summary),
		"red") ];
	}
	map targetMap = Storage::GetTargetMap ();
	map boot_target = targetMap[loader_device]:$[];
	string target_name = "";
	if (boot_target == $[])
	{
	    target_name = loader_device;
	    if (target_name == "mbr_md")
	    {
		list<string> mbrs = maplist (string d, integer id,
		    Md2Partitions (BootPartitionDevice),
		{
		    map p_dev = Storage::GetDiskPartition (d);
		    return p_dev["disk"]:"";
		});
		// summary part, %1 is a list of device names
		target_name = sformat (_("Master boot records of disks %1"),
		    mergestring (mbrs, ", "));
	    }
	}
	else
	{
	    target_name = boot_target["name"]:"disk";
	}
	target_name = AddMbrToDescription (target_name, loader_device);

	list<string> result = [];
	// summary text, %1 is bootloader name (eg. LILO)
	result = add (result, sformat (_("Boot Loader Type: %1"),
		getLoaderName (getLoaderType (false), `summary)));
	// summary text, location is location description (eg. /dev/hda)
	result = add (result, sformat (_("Location: %1"), target_name));
	list<string> sects = [];
	foreach (map<string,any> s, sections, {
	    string title = s["name"]:"";
		// section name "suffix" for default section
	    string def = title == globals["default"]:"" ? _(" (default)") : "";
	    sects = add (sects, String::EscapeTags (sformat ("+ %1%2", title, def)));
	});
	// summary text. %1 is list of bootloader sections
	result = add (result, sformat (_("Sections:<br>%1"),
	    mergestring (sects, "<br>")));
	if (loader_device == "/dev/null")
	    // summary text
	    result = add (result, _("Do not install boot loader; just create 
configuration files"));

	return result;
    }

    /**
      * Update read settings to new version of configuration files
      */
    global define void Update () {
	y2debug ("No generic update function available");
    }

/**
 * Write bootloader settings to disk
 * @return boolean true on success
 */
global define boolean Write () {
    y2error ("No generic write function available");
    return false;
}


// end of generic versions of bootloader-specific functions
//-----------------------------------------------------------------------------
// common functions start

// bootloader type handling functions

/**
  * Set attributes of specified bootloader to variable containing
  * attributes of currently used bootloader, call its initializer
  * @param loader_type string loader type to initialize
  */
global define void setCurrentLoaderAttribs (string loader_type) {
    y2milestone ("Setting attributes for bootloader %1", loader_type);
    // testsuite hack
    if (Mode::test ())
        return;
    if (loader_type == nil)
    {
	y2error ("Setting loader type to nil, this is wrong");
	return;
    }

    // FIXME: this should be blInitializer in switcher.ycp for code cleanness
    // and understandability
    if (bootloader_attribs[loader_type, "initializer"]:nil != nil)
    {
	y2milestone ("Running bootloader initializer");
	void () toEval = (void ()) (bootloader_attribs[loader_type, "initializer"]:nil);
	toEval ();
	y2milestone ("Initializer finished");
    }
    else
    {
	y2error ("No initializer found for >>%1<<", loader_type);
	current_bootloader_attribs = $[];
    }

    current_bootloader_attribs = (map<string, any>) union (
	current_bootloader_attribs,
	(map<string, any>) eval (bootloader_attribs[loader_type]:$[])
    );
}

/**
 * Check whether loader with specified name is supported
 * @param loader string name of loader to check
 * @return string the loader name if supported, "none" otherwise
 */
string SupportedLoader (string loader) {
    if (contains (["grub", "lilo", "zipl", "ppc", "elilo"], loader))
	return loader;
    return "none";
}

/**
  * Get currently used bootloader, detect if not set yet
  * @param recheck boolean force checking bootloader
  * @return string botloader type
  */
global define string getLoaderType (boolean recheck) {
    if ((! recheck) && (loader_type != nil))
        return loader_type;
    // read bootloader to use from disk
    if (Mode::update () || Mode::normal () || Mode::repair ())
    {
	loader_type = (string)SCR::Read (.sysconfig.bootloader.LOADER_TYPE);
	if (loader_type != nil && loader_type != "")
	{
	    if (loader_type == "s390")
	        loader_type = "zipl";
	    if (loader_type == "lilo" && Arch::ppc ())
	        loader_type = "ppc";
	    y2milestone ("Sysconfig bootloader is %1, using", loader_type);
	    loader_type = SupportedLoader (loader_type);
	    y2milestone ("Sysconfig bootloader is %1, using", loader_type);
	    setCurrentLoaderAttribs (loader_type);
	    return loader_type;
	}
	if (Mode::update ())
	{
	  // FIXME: this is extremely broken, no arch specifica here !!
	    if (Arch::i386 ())
	    { 
		// no sysconfig variable -> old version installed -> use LILO
		loader_type = "lilo";
		loader_type = SupportedLoader (loader_type);
		setCurrentLoaderAttribs (loader_type);
		return loader_type;
	    }
	}
    }
    // detect bootloader
    loader_type = (string)SCR::Read (.probe.boot_arch);
    if (loader_type == "s390")
      loader_type = "zipl";
    y2milestone ("Bootloader detection returned %1", loader_type);
    // lslezak@: Arch::is_xenU() returns true only in PV guest
    if (Arch::is_uml () || Arch::is_xenU())
    {
	// y2milestone ("Not installing any bootloader for UML/Xen PV");
	// loader_type = "none";
	// bnc #380982 - pygrub cannot boot kernel
	// added installation of bootloader
	y2milestone ("It is XEN domU and the bootloader should be installed");

    }
    if ((Arch::i386() || Arch::x86_64()) && Linuxrc::InstallInf("EFI") == "1")
    {
	loader_type = "elilo";
    }

    if (loader_type == "grub")
    {
	prefer_lilo = true;
    }

    loader_type = SupportedLoader (loader_type);
    y2milestone ("Detected bootloader %1", loader_type);
    setCurrentLoaderAttribs (loader_type);
    return loader_type;
}



/**
 * The function handle selecting and deselecting packages (bootloaders)
 * @return boolean true on success
 */
boolean solvePackage()
{
	boolean ret = false;
	if (globals["trusted_grub"]:"" == "true")
	{

		PackagesProposal::RemoveResolvables("yast2-bootloader", `package, ["grub"]);
		y2milestone("deselect grub for installation");
		ret = true;

	}
	return ret;
}


/**
  * set type of bootloader
  * @param bootloader string type of bootloader
  */
global define void setLoaderType (string bootloader) {
    if (bootloader == nil)
    {
        y2milestone ("Resetting the loader type");
        loader_type = nil;
    }
    y2milestone ("Setting bootloader to >>%1<<", bootloader);
    if (bootloader != nil
        && contains(bootloaders, bootloader)
        && ! Mode::test ())
    {
	// added kexec-tools fate# 303395
	// if kexec option is equal 0 or running live installation 
	// doesn't install kexec-tools

	list<string> bootloader_packages = bootloader_attribs[bootloader, "required_packages"]:[];
	if ((! Mode::live_installation()) 
	   && (Linuxrc::InstallInf ("kexec_reboot") != "0"))
	{
		bootloader_packages = add(bootloader_packages, "kexec-tools");
	}
	
	if (globals["trusted_grub"]:"" == "true")
	{
		if (contains(bootloader_packages, "grub"))
			bootloader_packages = filter(string key, bootloader_packages, {return (key !="grub"); });

		bootloader_packages = add(bootloader_packages, "trustedgrub");
	}

	y2milestone("Bootloader packages: %1", bootloader_packages);

        // don't configure package manager during autoinstallation preparing
        if (Mode::normal () && (! (Mode::config () || Mode::repair ())))
        {
	    y2milestone("Install bootloader packages");
	    PackageSystem::InstallAll (bootloader_packages);
        }
        else if (Stage::initial () && (! (Mode::repair ())))
        {
	    boolean pkg_added = false;
	    foreach (string p, bootloader_packages, {
	       y2milestone("Select bootloader package: %1", p);
	       PackagesProposal::AddResolvables ("yast2-bootloader", `package, [p]);
	       pkg_added = true;
		
	    });
	    if (pkg_added)
	    {
		boolean ret = solvePackage();
	    }
        }
    }
    else if (! Mode::test ())
    {
        y2error ("Unknown bootloader");
    }
    loader_type = bootloader;
    if (loader_type != nil)
        setCurrentLoaderAttribs (loader_type);
    y2milestone ("Loader type set");
}

/**
  * List bootloaders available for configured architecture
  * @return a list of bootloaders
  */
global define list<string> getBootloaders () {
    if (Mode::config ())
    {
        return ["grub", "lilo", "elilo", "zipl", "ppc", "default", "none"];
    }
    list<string> ret = [
	getLoaderType (false),
	(string)SCR::Read (.probe.boot_arch)
    ];
    if (Arch::i386 () || Arch::x86_64 ())
    {
        ret = (list<string>)merge (ret, ["lilo", "grub"]);
	if (Arch::x86_64 ())
	    ret = (list<string>)merge (ret, ["elilo"]);
    }
    // in order not to display it twice when "none" is selected
    ret = filter (string l, ret, {
      return l != "none";
    });
    ret = toset (ret);
    ret = add (ret, "none");
    return ret;
}

/**
  * Search for section passed
  * @return integer index number
  */

global define integer Section2Index (string section_name)
{
    integer index = -1;
    integer sectnum = -1;

    foreach (map<string,any> s, BootCommon::sections, {
            index = index + 1;
	if (s["name"]:"" == section_name)
	    sectnum = index;
    });

    y2milestone ("ret: %1", sectnum);
    return sectnum;
}

/** FATE#305008: Failover boot configurations for md arrays with redundancy
 * Check if devices has same partition number and if they are from different disks
 *
 * @param list <string> list of devices 
 * @return boolean true on success
 */
boolean checkDifferentDisks (list <string> devices)
{
    boolean ret = false;
    list <string> disks = [];
    string no_partition = "";
    foreach(string dev, devices,
    {
	map p_dev = Storage::GetDiskPartition (dev);
	if (!contains(disks, p_dev["disk"]:""))
	    disks=add(disks,p_dev["disk"]:"");
	else
	{
	    y2milestone("Same disk for md array -> disable synchronize md arrays");
	    break;
	}
	// add disk from partition to md_physical_disks
	if (!contains(md_physical_disks, p_dev["disk"]:""))
	    md_physical_disks = add(md_physical_disks,p_dev["disk"]:"");

	string no_p = tostring(p_dev["nr"]:nil);
	if (no_p == "")
	{
	    y2error("Wrong number of partition: %1 from Storage::GetDiskPartition: %2", dev, p_dev);
	    break;
	}
	if (no_partition == "")
	    no_partition = no_p;
	else
	    if (no_partition == no_p)
		ret = true;
	    else
		y2milestone("Different number of partitions -> disable synchronize md arrays");

    });

    y2milestone("checkDifferentDisks for devices: %1 return: %2",devices, ret);

    return ret;
}

/** FATE#305008: Failover boot configurations for md arrays with redundancy
 * Check if device are build from 2 partitions with same number but from different disks
 *
 * @param map<string,map> tm taregte map from storage
 * @param string device (md device)
 * @return true if device is from 2 partisions with same number and different disks
 */
boolean checkMDDevices(map<string,map> tm, string device)
{
    boolean ret = false;
    map <string, any> tm_dm =  (map<string, any>) tm["/dev/md"]:$[];

    md_physical_disks = [];
    // find partitions in target map
    foreach(map p, tm_dm["partitions"]:[], 
    {
	if (p["device"]:"" == device)
	{
	    if (p["raid_type"]:"" == "raid1")
	    {
		list <string> p_devices = p["devices"]:[];
		if (size(p_devices) == 2)
		    ret = checkDifferentDisks(p_devices);
		else
		    y2milestone("Device: %1 doesn't contain 2 partitions: %2", device, p_devices);

	    } else {
		y2milestone ("Device: %1 is not on raid1: %2",device, p["raid_type"]:"");
	    }
	}
    });

    if ((size(md_physical_disks) != 2) || (contains(md_physical_disks, "")))
	y2milestone("device: %1 is based on md_physical_disks: %2 is not valid for enable redundancy",
 		    device, md_physical_disks);

    if (ret)
	y2milestone("device: %1 is based on md_physical_disks: %2 is valid for enable redundancy",
		    device, md_physical_disks);

    return ret;
}


/** FATE#305008: Failover boot configurations for md arrays with redundancy
 * Function check partitions and set redundancy available if 
 * partitioning of disk allows it.
 * It means if md array is based on 2 partitions with same number but 2 different disks
 * E.g. /dev/md0 is from /dev/sda1 and /dev/sb1 and /dev/md0 is "/"
 * There is possible only boot from MBR (GRUB not generic boot code)
 *
 * @return boolean true on success
 */

global boolean checkMDSettings ()
{
    boolean ret = false;
    map<string,map> tm = (map<string,map>)Storage::GetTargetMap();

    if (!haskey(tm, "/dev/md"))
    {
	y2milestone("Doesn't include md raid");
	return ret;
    }
    list<string> boot_devices = [];
    if ((BootPartitionDevice != "") && (BootPartitionDevice != nil))
	boot_devices = add(boot_devices, BootPartitionDevice);
    if ((BootPartitionDevice != RootPartitionDevice) && (RootPartitionDevice != "")
	&& (BootPartitionDevice != nil))
	boot_devices = add(boot_devices, RootPartitionDevice);
    if ((ExtendedPartitionDevice != "")&& (ExtendedPartitionDevice != nil))
	boot_devices = add(boot_devices, ExtendedPartitionDevice);

    y2milestone("Devices for analyse of redundacy md array: %1", boot_devices);
    foreach(string dev, boot_devices,
    {
	ret = checkMDDevices(tm, dev);
	if (!ret)
	{
	    y2milestone("Skip enable redundancy of md arrays");
	    break;
	}
    });

    return ret;
}

/** FATE#305008: Failover boot configurations for md arrays with redundancy
 * Function prapare disks for synchronizing of md array
 * 
 * @return string includes disks separatet by ","
 */

global string addMDSettingsToGlobals()
{
    string ret = "";

    if (checkMDSettings())
	ret = mergestring(md_physical_disks,",");
    return ret;
}

/** FATE#305008: Failover boot configurations for md arrays with redundancy
 * Verify if proposal includes md array with 2 diferent disks
 *
 * @return boolean true if there is md array based on 2 disks
 */
global boolean VerifyMDArray ()
{
    boolean ret = false;
    if (haskey(globals, "boot_md_mbr"))
    {
	string md_array =  globals["boot_md_mbr"]:"";
	list<string> disks = splitstring(md_array,",");
	disks = filter(string v, disks, {return (v !="");});
	if (size(disks) == 2)
	{
	    y2milestone("boot_md_mbr includes 2 disks: %1", disks);
	    ret = true;
	}

    }
    return ret;
}

/** bnc #364904
 * Function parse zipl list names if default section is menu
 * 
 * @param string (string) list of names
 * @param string position of default name in list
 * @return string name of default section from list
 */
string parseListDefault(string names, string position)
{
	string ret = "";

	y2milestone("section names (string) list: %1 and default name position in list: %2", names, position);
	if ((names == "") || (position == ""))
		return ret;

	if (search(names, ",") != nil)
	{
		string tmp_names = deletechars(names, " ");
		list <string> list_names = splitstring(tmp_names, ",");
		ret = list_names[(tointeger(position)-1)]:"";
	} else {
		ret = names;
	}

	return ret;
}

/** bnc #364904
 * Function check if default section is menu
 * if yes it tries to find default section in 
 *  list of names from menu section
 *
 * @param string name of default BootCommon::globals["default"]:""
 * @return string name of default section
 */

global string checkZiplDefault(string def)
{
    string def_section_name = def;

    if (getLoaderType (false) == "zipl")
    {
	foreach(map<string,any> section, BootCommon::sections,
	{
	    if (section["name"]:"" == def_section_name)
	    {
		if (section["type"]:"" == "menu")
		{
		    string def_position = section["default"]:"";
		    def_section_name = parseListDefault(section["list"]:"", def_position);

		} else {
		    break;
		}
	    }
        });

    }

    y2milestone("name of default section: %1", def_section_name);
    return def_section_name;
}

}

/*
 * Local variables:
 *     mode: ycp
 *     mode: font-lock
 *     mode: auto-fill
 *     indent-level: 4
 *     fill-column: 78
 * End:
 */
