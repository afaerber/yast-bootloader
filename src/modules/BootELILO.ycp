
/**
 * File:
 *      modules/BootELILO.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Module containing specific functions for ELILO configuration
 *      and installation
 *
 * Authors:
 *      Joachim Plack <jplack@suse.de>
 *      Jiri Srain <jsrain@suse.cz>
 *      Andreas Schwab <schwab@suse.de>
 *      Olaf Dabrunz <od@suse.de>
 *      Philipp Thomas <pth@suse.de>
 *
 * $Id$
 *
 */

{

// FIXME paths will be probably changed because of bugzilla 21644

module "BootELILO";

textdomain "bootloader";

import "BootArch";
import "BootCommon";
import "Installation";
import "Kernel";
import "Mode";
import "Report";
import "Stage";
import "Storage";
import "String";
import "Arch";

include "bootloader/elilo/helps.ycp";
include "bootloader/routines/popups.ycp";
include "bootloader/generic/dialogs.ycp";


// private variables

/**
  * Name of EFI entry when read settings
  */
global string old_efi_entry = nil;

/**
  * elilo.conf path
  */
global string elilo_conf_filename = "/boot/efi/SuSE/elilo.conf";

/**
  * True if EFI entry should be recreated
  */
global boolean create_efi_entry = true;

string efi_vendor = "SuSE";

/**
 * bnc #450682 - adding boot entry to EFI
 * true is label was added
 */

global boolean added_label_to_efi = false;

/**
 * Is the /sys/firmware/efi directory available?
 */
boolean efi_available = true;

// misc. functions

/**
  * Return mountpoint of partition holding EFI data
  * @return mountpoint if partition holding EFI data
  */
global define string getEfiMountPoint () {
    string mountpoint = "/";
    // FIXME: UGLY HACK because of testsuites
    map mountpoints = $[];
    if (Mode::test ())
        mountpoints = $["/" : ["/dev/hda2"], "/boot" : ["/dev/hda1"]];
    else
        mountpoints = Storage::GetMountPoints();
    if (haskey (mountpoints, "/boot/efi"))
    {
        mountpoint = "/boot/efi";
    }
    else if (haskey (mountpoints, "/boot"))
    {
        mountpoint = "/boot";
    }
    y2milestone ("Mountpoint of EFI: %1", mountpoint);
    return mountpoint;
}


/**
  * Get directory containing elilo.conf relative to EFI partition's root
  * @return directory containing elilo.conf relative to EFI root
  */
global define string getEliloConfSubdir () {
    return sformat ("/efi/%1", efi_vendor);
}


/**
  * Get path of elilo.conf relative to EFI partition's root
  * @return string path of elilo.conf relative to EFI partition's root
  */
global define string getEliloConfSubpath () {
    return sformat ("%1/elilo.conf", getEliloConfSubdir ());
}


/**
  * Return path to elilo.conf file
  * @return string path to elilo.conf
  */
global define string getEliloConfFilename () {
    // FIXME config file name location should be read from Library
    //  and it should not be needed here!!!
    string ret = sformat ("%1/efi/%2/elilo.conf", getEfiMountPoint (),
        efi_vendor);
    y2milestone ("elilo.conf sould be located at %1", ret);
    return ret;
}

// wrapper function to adjust to new grub name sceme
map<string,any> CreateLinuxSection (string title) {
    map<string,any> section =
      BootCommon::CreateLinuxSection (title);

    // don't translate label bnc #151486
    section["description"] = section["name"]:"";
    section["name"] = title;

    // replace "kernel" by "image"
    if (haskey(section, "kernel")) {
      section["image"] = section["kernel"]:"";
      section = remove(section, "kernel");
    }
 
    return section;
}



/**
 * Propose sections to bootloader menu
 * modifies internal structures
 */
global void CreateSections () {
    map<string,any> linux = CreateLinuxSection ("linux");
    map<string,any> failsafe = CreateLinuxSection ("failsafe");

    // bnc#588609 - Problems writing elilo
    map<string,any> xen = $[];
    if (BootCommon::XenPresent ())
       xen = CreateLinuxSection ("xen");

    // append for default section is in global
    // FIXME do it later
    //    if (haskey (linux, "append"))
    //  	linux = remove (linux, "append");
    if ((xen != nil) && (size(xen) >0))
       BootCommon::sections = [ linux, failsafe, xen ];
    else
       BootCommon::sections = [ linux, failsafe ];
}


/**
 * Propose global options of bootloader
 * modifies internal structures
 */
global void CreateGlobals () {
    BootCommon::globals = $[
    // FIXME do it later
    //	"append" : BootArch::DefaultKernelParams (""),
    //	"default" : BootCommon::translateSectionTitle ("linux"),
	"default" : "linux",
	"timeout" : "80",
	"prompt" : "true",
    // bnc #438276 - remove deprecated 'read-only'
    //	"read-only" : "true",
	"relocatable" : "true"
    ];

}


// general functions


/**
  * Export bootloader settings to a map
  * @return bootloader settings
  */
global define map Export () {
    map ret = BootCommon::Export ();
    ret["old_efi_entry"] = old_efi_entry;
    ret["elilo_conf_filename"] = elilo_conf_filename;
    ret["create_efi_entry"] = create_efi_entry;
    return ret;
}


/**
  * Import settings from a map
  * @param settings map of bootloader settings
  */
global define boolean Import (map settings) {
    BootCommon::Import (settings);
    old_efi_entry = (string) (settings["old_efi_entry"]:nil);
    elilo_conf_filename = getEliloConfFilename ();
    create_efi_entry
        = settings["create_efi_entry"]:(settings["location"]:"" != "");
    return true;
}


/**
  * Read settings from disk
  * @param reread boolean true to force reread settings from system
  * @param avoid_reading_device_map do not read new device map from file, use
  * internal data
  * @return boolean true on success
  */
global define boolean Read (boolean reread, boolean avoid_reading_device_map) {
	import "Product";
	boolean efi_entry_found = false;
	elilo_conf_filename = getEliloConfFilename ();
	// copy old elilo.conf from /boot/<something> to /etc in case of upgrade
	// (if /etc/elilo.conf doesn't exist)
	if (SCR::Read (.target.size, "/etc/elilo.conf") <= 0
	    && SCR::Read (.target.size, elilo_conf_filename) > 0)
	{
	    SCR::Execute (.target.bash, sformat (
		"/bin/cp %1 /etc/elilo.conf", elilo_conf_filename));
	}
	SCR::Execute (.target.bash, "/bin/touch /etc/elilo.conf");
	BootCommon::DetectDisks ();
	boolean ret = BootCommon::Read (reread, avoid_reading_device_map);

	// check for meaningless EFI entry name in sysconfig
	if ( !haskey(BootCommon::globals,"boot_efilabel")
	    || BootCommon::globals["boot_efilabel"]:"" == "mbr"
	    || BootCommon::globals["boot_efilabel"]:"" == ""
	    || BootCommon::globals["boot_efilabel"]:"" == nil )
	{
	    string efi_path = BootCommon::replaceAll (
		getEliloConfSubpath (), "/", "\\");
	    // Read Firmware setting from NVRam
	    map efi_status = (map)SCR::Execute (.target.bash_output, sformat (
		"/usr/sbin/efibootmgr |grep \"%1\"", efi_path));
	    if (efi_status["exit"]:0 != 0)
	    {
		BootCommon::globals["boot_efilabel"] = Product::name;
	    }
	    else
	    {
		string output = efi_status["stdout"]:"";
		list lines = splitstring (output, "\n");
		output = lines[0]:"";
		if (regexpmatch (output, "Boot.*\\* (.*)  HD"))
		{
		    BootCommon::globals["boot_efilabel"]
			= regexpsub (output, "Boot.*\\* (.*)  HD", "\\1");
		    efi_entry_found = true;
		}
		else
		{
		    BootCommon::globals["boot_efilabel"] = Product::name;
		}
	    }
	}
	else
	{
	    efi_entry_found = 0 == SCR::Execute (.target.bash, sformat (
		"/usr/sbin/efibootmgr |grep \"%1\"",
		BootCommon::globals["boot_efilabel"]:"")
	    );
	}
	create_efi_entry = !efi_entry_found;
	old_efi_entry = efi_entry_found
	    ? BootCommon::globals["boot_efilabel"]:""
	    : (string)nil;
	return ret;
}


/**
  * Reset bootloader settings
  */
global define void Reset (boolean init) {
    if (Mode::autoinst ())
        return;
    create_efi_entry = true;
    BootCommon::Reset(init);
}


/**
  * Propose bootloader settings
  */
global define void Propose () {
    import "Product";
    if (! BootCommon::was_proposed)
    {
        create_efi_entry = true;
	// make sure the code handling globals below triggers and that
	// boot_efilabel is recreated
	if ( haskey(BootCommon::globals, "boot_efilabel") )
	    BootCommon::globals = remove(BootCommon::globals, "boot_efilabel");
    }
    if (! Stage::initial ())
        create_efi_entry = true;
    if (Mode::update ())
        create_efi_entry = false;
    efi_available = 0 == (integer)SCR::Execute (.target.bash, "test -d /sys/firmware/efi");
    if (! efi_available)
	create_efi_entry = false;
    elilo_conf_filename = getEliloConfFilename ();
    BootCommon::DetectDisks ();
    BootCommon::del_parts = BootCommon::getPartitionList (`deleted);

    if (BootCommon::sections == nil || size (BootCommon::sections) == 0)
    {
        CreateSections ();
        BootCommon::kernelCmdLine = Kernel::GetCmdLine ();
    }
    else
    {
        if (Mode::autoinst ())
        {
	    y2debug ("Nothing to do for propose in AI mode");
        }
        else
	BootCommon::FixSections (BootELILO::CreateSections);
    }

    if (BootCommon::globals == nil || size (BootCommon::globals) == 0)
    {
        CreateGlobals ();
    }

    if (BootCommon::globals["boot_efilabel"]:nil == nil ||
	BootCommon::globals["boot_efilabel"]:nil == "")
    {
	BootCommon::globals["boot_efilabel"] = Product::name;
    }

    if (Mode::installation())
	BootCommon::UpdateProposalFromClient();

    y2milestone ("EFI entry name: %1", BootCommon::globals["boot_efilabel"]:"");
    y2milestone ("Proposed sections: %1", BootCommon::sections);
    y2milestone ("Proposed globals: %1", BootCommon::globals);
}


/**
 * Save all bootloader configuration files
 * @return boolean true if success
 */
global boolean Save (boolean clean, boolean init, boolean flush) {
    boolean ret = BootCommon::Save (clean, init, flush);
    importMetaData();
    return ret;
}


/**
  * Display bootloader summary
  * @return a list of summary lines
  */
global define list<string> Summary () {
    // summary text, %1 is bootloader name (eg. LILO)
    list<string> result = [ sformat (_("Boot loader type: %1"),
        BootCommon::getLoaderName (BootCommon::getLoaderType (false), `summary)) ];

    if (BootCommon::globals["boot_efilabel"]:"" == "" || !create_efi_entry )
    {
        result =
	    // summary text
	    add (result, _("Do Not Create EFI Boot Manager Entry"));
    }
    else
    {
        result = add (result, sformat (
	// summary text, %1 is label of the entry of EFI boot manager
	_("Create EFI Boot Manager Entry %1"),
	BootCommon::globals["boot_efilabel"]:""));
    }
    list<string> sects = [];
    foreach (map<string,any> s, BootCommon::sections, {
        string title = s["name"]:"";
            // section name "suffix" for default section
        string def = title == BootCommon::globals["default"]:"" ?
	      _(" (default)") :
	      "";
        sects = add (sects, String::EscapeTags (sformat ("+ %1%2", title, def)));
    });
    // summary text. %1 is list of bootloader sections
    result = add (result, sformat (_("Sections:<br>%1"),
        mergestring (sects, "<br>")));
    return result;
}


/**
 * Update read settings to new version of configuration files
 */
global define void Update () {
    /*
     * Update global options of bootloader
     * modifies internal structures
     */
    if (BootCommon::globals["timeout"]:"" == "")
        BootCommon::globals["timeout"] = "8";
    BootCommon::globals["append"] = BootArch::DefaultKernelParams ("");

    BootCommon::UpdateSections ();
    // FIXME EFI entry name
}


/**
  * Install the bootloader, display a popup with log if something
  *  goes wrong
  * @param command string command to install the bootloader
  * @param logfile string filename of file used to write bootloader log
  * @return boolean true on success
  */
// FIXME get rid of this function
define boolean installBootLoader (string command, string logfile) {
    y2milestone ("Running command %1", command);
    map exit = (map)SCR::Execute (.target.bash_output, command);
    boolean ret = 0 == exit["exit"]:1;
    if (! ret)
    {
        y2milestone ("Exit code of %1: %2", command, exit["exit"]:-1);
        string log = (string)SCR::Read (.target.string, logfile);
        log = log + exit["stdout"]:"" + exit["stderr"]:"";
        if (exit["exit"]:1 == 139)
        {
            // means: process received signal SIGSEGV
            // please, use some usual translation
            // proofreaders: don't change this text
            log = log + _("Segmentation fault");
        }

        errorWithLogPopup (sformat (
            // error popup - label, %1 is bootloader name
            _("Error Occurred while Installing %1"),
            BootCommon::getLoaderName (BootCommon::getLoaderType (false), `summary)), log);
    } else {
	added_label_to_efi = true;
	y2milestone("Adding label to EFI finish successful");
    }
    return ret;
}


/** bnc #717828
 * Let elilo do all the efi label work.
 */

boolean updateEFILabel()
{
    // now elilo manages efi boot entries
    string cmd = "/sbin/elilo --refresh-EBM";
    y2milestone("running command %1: %2", cmd, (map)SCR::Execute(.target.bash_output, cmd));

    return true;
}


/**
  * Write bootloader settings to disk
  * @return boolean true on success
  */
global define boolean Write () {

    y2milestone("run Write function from BootELILO");
    //	SCR::Execute (.target.bash, "/sbin/elilo");
    boolean ret = BootCommon::UpdateBootloader ();
    if (ret == nil)
	ret = false;

// FIXME find a better way to report status
    if (ret && ! efi_available) {
	Popup::TimedMessage(
_("System was not booted via EFI firmware. To boot your
computer, you need to load ELILO via the EFI shell."), 10);
    }

    if (ret) ret = updateEFILabel();

    return ret;
}


global symbol WizardSequenzer() {
    y2milestone("Call generic WizardSequenzer");
    return `generic_new;
}


global map<string,symbol()> Dialogs () {
    return $[
	"loader"	: genericBootLoaderOptionsDialog,
    ];
}

/**
  * Set section to boot on next reboot.
  * @param section string section to boot
  * @return boolean true on success
  */
global define boolean FlagBootDefaultOnce (string section) {
	/* For now a dummy */
	return true;
}

/**
  * Return map of provided functions
  * @return a map of functions (eg. $["write"::Write])
  */
global map<string, any> GetFunctions () {
    return $[
        "export"		: Export,
        "import"		: Import,
        "read"			: Read,
	"reset"			: Reset,
        "propose"		: Propose,
        "save"			: Save,
        "summary"		: Summary,
        "update"		: Update,
        "write"			: Write,
        "widgets"		: genericWidgets,
        "wizard_sequencer"	: WizardSequenzer,
        "dialogs"		: Dialogs,
        "section_types"		: section_types,
	"flagbootdefaultonce"	: FlagBootDefaultOnce,
    ];
}

/**
 * Initializer of ELILO bootloader
 */
global void Initializer () {
    y2milestone ("Called ELILO initializer");
    BootCommon::current_bootloader_attribs = $[
        "propose" : true,
        "read" : true,
        "scratch" : true,
        "restore_mbr" : true,
        "bootloader_on_disk" : true,
    ];

    BootCommon::help_messages = (map<string,string>)
      union(BootCommon::help_messages,
    	mapmap(string key, string val, elilo_help_messages,
    	    { return $[ "elilo_" + key : val ]; }
    	       )
    	);
    y2debug("Initialized help_messages to %1", BootCommon::help_messages);
    BootCommon::descriptions = (map<string,string>)
      union(BootCommon::descriptions,
    	mapmap(string key, string val, elilo_descriptions,
    	    { return $[ "elilo_" + key : val ]; }
    	       )
    	);
    y2debug("Initialized help_messages to %1", BootCommon::help_messages);

    BootCommon::InitializeLibrary (false, "elilo");
    importMetaData();
}

/**
 * Constructor
 */
global define void BootELILO () {
    BootCommon::bootloader_attribs["elilo"] = $[
	"required_packages" : ["elilo", "efibootmgr"],
	"loader_name" : "ELILO",
	"initializer" : BootELILO::Initializer,
    ];
}
 
} // EOF

/*
 * Local variables:
 *     mode: ycp
 *     mode: font-lock
 *     mode: auto-fill
 *     indent-level: 4
 *     fill-column: 78
 * End:
 */
