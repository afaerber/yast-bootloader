/**
 * File:
 *      include/bootloader/routines/misc-common.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Miscelaneous functions for bootloader configuration and installation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *      Olaf Dabrunz <od@suse.de>
 *
 * $Id$
 *
 * WARNING:
 *      To be included to BootCommon.ycp only, requires function
 *      getLoaderType to avoid include-import cycle
 *      Use import "BootCommon" instead.
 */



{

    textdomain "bootloader";
    import "Mode";
    import "Stage";

    import "Storage";
    import "StorageDevices";
    import "Report";
    import "Kernel";
    import "Misc";
    import "ProductFeatures";
    import "Directory";
    import "Installation";
    import "FileUtils";

// bootloader attributes handling functions

    global map<string, integer> Md2Partitions (string md_device);
    global void DetectDisks ();
    global string getBootPartition();
    global string DiskOrderSummary ();
    global list<string> DisksOrder ();
    global void ProposeDeviceMap ();
    global boolean DisksChanged ();
    global define list<string> getPartitionList(symbol type);

    include "bootloader/routines/i386.ycp";


    /**
      * return printable name of bootloader
      * @param bootloader string bootloader type internal string
      * @param mode symbol `combo or `summary (because of capitalization)
      * @return string printable bootloader name
      */
    global define string getLoaderName (string bootloader, symbol mode) ``{
	if (bootloader == "none")
	{
	    return mode == `summary
		// summary string
		? _("Do not install any boot loader")
		// combo box item
		: _("Do Not Install Any Boot Loader");
	}
	if (bootloader == "default")
	{
	    return mode == `summary
		// summary string
		? _("Install the default boot loader")
		// combo box item
		: _("Install Default Boot Loader");
	}
	string fallback_name = mode == `summary
	    // summary string
	    ? _("Boot loader")
	    // combo box item
	    : _("Boot Loader");
	// fallback bootloader name, keep short
	return bootloader_attribs[bootloader, "loader_name"]:fallback_name;
    }

    /**
      * Get value of specified boolean bootloader attribute
      * @param attrib string attribute name
      * @return boolean value of attribute
      */
    global define boolean getBooleanAttrib (string attrib) ``{
	return current_bootloader_attribs[attrib]:false;
    }

    /**
      * Get value of specified bootloader attribute
      * @param attrib string attribute name
      * @param defaultv any default value of the attribute (if not found)
      * @return any value of attribute
      */
    global define any getAnyTypeAttrib (string attrib, any defaultv) ``{
        return current_bootloader_attribs[attrib]:defaultv;
    }

// other misc functions



    /**
      * Update the text of countdown widget
      * @param bootloader string printable name of used bootloader
      */
    global define void updateTimeoutPopupForFloppy (string bootloader) ``{
	if (Mode::normal ())
	    return;

        string confirm_boot_msg = Misc::boot_msg;
        // data saved to floppy disk
        string msg = sformat (
            // popup, %1 is bootloader name
            _("The %1 boot sector has been written to the floppy disk."),
            bootloader);
        msg = msg + "\n";
	// always hard boot
        // If LILO was written on floppy disk and we need
        // to do a hard reboot (because a different kernel
        // was installed), tell the user to leave the floppy
        // inserted.
        msg = msg
            // popup - continuing
            + _("Leave the floppy disk in the drive.");

        if ( size (confirm_boot_msg) > 0 )
        {
            msg = msg + "\n" + confirm_boot_msg;
        }
        Misc::boot_msg = msg;
    }

    /**
      * Get the list of installed floppy drives
      * @return a list of floppy devices
      */
    global list<string> getFloppyDevices () ``{
        if (floppy_devices == nil)
        {
            list<map> floppies = (list<map>) SCR::Read (.probe.floppy);
            floppies = filter (map f, floppies,
                ``(f["model"]:"Floppy Disk" == "Floppy Disk"));
            floppy_devices = maplist (map f, floppies,
		``(f["dev_name"]:""));
            floppy_devices = filter (string f, floppy_devices, ``(f != ""));
        }
	return floppy_devices;
    }

    /**
     * converts array of string to path
     * @param strs list of string
     * @return path whose components are taken from strs
     */
    global define path list2path(list<string> strs) ``{
        path pth = .;
        foreach(string e, strs, ``{
            pth = add(pth, e);
        });
        return pth;
    }

global map<string,string> uuid_partitions = $[];
global map<string,string> id_partitions = $[];
global map<string,string> label_partitions = $[];
global map<string,string> path_partitions = $[];

global map<string,string> uuid_disks = $[];
global map<string,string> id_disks = $[];
global map<string,string> path_disks = $[];

/** FATE #302219 - Use and choose persistent device names for disk devices
 * Function prepare maps with mapping disks and partitions by uuid, id, path
 * and label.
 *
 */

global void MapDevices()
{
	string dev_by_something = "";
	map<string,map> devices = (map<string,map>)Storage::GetTargetMap();
	foreach (string k, map v, devices, 
	{
		// map disk by uuid
		if ((v["uuid"]:nil != "")  && (v["uuid"]:nil != nil))
		{
			dev_by_something = "/dev/disk/by-uuid/"+v["uuid"]:"";
			uuid_disks[dev_by_something]= k;	
		}
		// map disk by path
		if ((v["path"]:nil != "")  && (v["path"]:nil != nil))
		{
			dev_by_something = "/dev/disk/by-path/"+v["path"]:"";
			path_disks[dev_by_something]= k;
		}
		// map disk by id
		if ((v["udev_id"]:nil != nil) && (v["udev_id", 0]:nil != ""))
		{
			dev_by_something = "/dev/disk/by-id/"+v["udev_id", 0]:"";
			id_disks[dev_by_something] = k;
		}
		// map partitions from disk...

		foreach (map p, (list<map>)(v["partitions"]:[]), 
		{
			// bnc#687878 - mountby uuid not respected in menu.lst
			// if there is "not created" partition and flag for "it" is not set
			if ((p["create"]:nil == true) && (Mode::installation()))
			{
			    if (BootCommon::proposed_partition == "")
				BootCommon::proposed_partition = p["device"]:"";
			    BootCommon::all_devices_created = 1;
			}
			// map partition by uuid
			// watch out for fake uuids (shorter than 8 chars)
			if (size(p["uuid"]:"") > 8)
			{
				dev_by_something = "/dev/disk/by-uuid/"+p["uuid"]:"";
				uuid_partitions[dev_by_something]= p["device"]:"";
			}

			// map partition by path
			if ((p["path"]:nil != "")  && (p["path"]:nil != nil))
			{
				dev_by_something = "/dev/disk/by-path/"+p["path"]:"";
				path_partitions[dev_by_something]= p["device"]:"";	
			}

			// map partition by label
			if ((p["label"]:nil != "")  && (p["label"]:nil != nil))
			{
				dev_by_something = "/dev/disk/by-label/"+p["label"]:"";
				label_partitions[dev_by_something]= p["device"]:"";
			}

			// map disk by id
			if ((p["udev_id"]:nil != nil) && (p["udev_id", 0]:nil != ""))
			{
				dev_by_something = "/dev/disk/by-id/"+p["udev_id", 0]:"";
				id_partitions[dev_by_something] = p["device"]:"";
			}

		}); // end of foreach (map p, (list<map>)(v["partitions"]:[]),
	}); // end of foreach (string k, map v, devices,

	if (Mode::installation() && BootCommon::all_devices_created == 2)
	{
	    BootCommon::all_devices_created = 0;
	    y2milestone("set status for all_devices to \"created\"");
	}

	y2milestone("disks mapping by-id: %1", id_disks);
	y2milestone("disks mapping by-uuid: %1", uuid_disks);
	y2milestone("disks mapping by-path: %1", path_disks);

	y2milestone("partitions mapping by-id: %1", id_partitions);
	y2milestone("partitions mapping by-uuid: %1", uuid_partitions);
	y2milestone("partitions mapping by-path: %1", path_partitions);
	y2milestone("partitions mapping by-label: %1", label_partitions);

	BootCommon::all_devices = (map<string,string>)
	    union(id_disks,
	    union(uuid_disks,
	    union(path_disks,
	    union(id_partitions,
	    union(uuid_partitions,
	    union(path_partitions,
		  label_partitions
	))))));

	y2milestone("device name mapping to kernel names: %1", all_devices);
}


/** FATE #302219 - Use and choose persistent device names for disk devices
 * Converts a "/dev/disk/by-" device name to the corresponding kernel
 * device name, if a mapping for this name can be found in the map from
 * yast2-storage. If the given device name is not a "/dev/disk/by-" device
 * name, it is left unchanged. Also, if the information about the device
 * name cannot be found in the target map from yast2-storage, the device
 * name is left unchanged.
 *
 * @param dev string device name
 * @return string kernel device name
 */

global define string MountByDev2Dev(string dev) 
{
	y2milestone ("MountByDev2Dev: %1", dev);

	if (!regexpmatch(dev, "^/dev/disk/by-"))
	    return dev;
	string ret = dev;

	// check if it is device name by id
	if (search(dev, "/dev/disk/by-id/") != nil)
	{
		if (haskey(id_partitions, dev))
			ret = id_partitions[dev]:"";

		if (haskey(id_disks, dev))
			ret = id_disks[dev]:"";
		y2milestone("Device %1 was converted to: %2", dev, ret);
		return ret;	
	}

	// check if it is device name by uuid
	if (search(dev, "/dev/disk/by-uuid/") != nil)
	{
		if (haskey(uuid_partitions, dev))
			ret = uuid_partitions[dev]:"";

		if (haskey(uuid_disks, dev))
			ret = uuid_disks[dev]:"";
		y2milestone("Device %1 was converted to: %2", dev, ret);
		return ret;	
	}

	// check if it is device name by path
	if (search(dev, "/dev/disk/by-path/") != nil)
	{
		if (haskey(path_partitions, dev))
			ret = path_partitions[dev]:"";

		if (haskey(path_disks, dev))
			ret = path_disks[dev]:"";
		y2milestone("Device %1 was converted to: %2", dev, ret);
		return ret;	
	}

	// check if it is device name by label
	// only partition are supported
	if (search(dev, "/dev/disk/by-label/") != nil)
	{
		if (haskey(label_partitions, dev))
			ret = label_partitions[dev]:"";
		y2milestone("Device %1 was converted to: %2", dev, ret);
		return ret;	
	}

	y2milestone("Device %1 was converted to: %2", dev, ret);
	return ret;
}
/**
 * Function remap device map to device name (/dev/sda) 
 * or to label (ufo_disk)
 * @param map<string,string> device map
 * @return map<string,string> new device map
 */

global map<string,string> remapDeviceMap(map<string,string> device_map)
{	
	symbol by_mount = nil;
	if (Arch::ppc())
	    by_mount = `id;
        else
	    by_mount = Storage::GetDefaultMountBy();

	//by_mount = `id;
	if (by_mount == `label)
		return device_map;

	map<string,string> ret = $[];
	// convert device names in device map to the device names by device or label
	ret = mapmap (string k , string v, device_mapping, 
	{
		return $[BootCommon::MountByDev2Dev(k) : v];
	});

	return ret;
}

/**
 * Function remap globals settings "boot_custom" device name (/dev/sda) 
 * or to label (ufo_partition)
 * @param map<string,string> globals
 * @return map<string,string> globals
 */

global map<string,string> remapGlobals(map<string,string> globals_set)
{	
	symbol by_mount = nil;
	if (Arch::ppc())
	    by_mount = `id;
        else
	    by_mount = Storage::GetDefaultMountBy();

	//by_mount = `id;
	if (by_mount == `label)
		return globals_set;

	if (haskey(globals_set, "boot_custom"))
	{
		globals_set["boot_custom"] = BootCommon::MountByDev2Dev(globals_set["boot_custom"]:"");
	}

	if (haskey(globals_set, "boot_chrp_custom"))
	{
		globals_set["boot_chrp_custom"] = BootCommon::MountByDev2Dev(globals_set["boot_chrp_custom"]:"");
	}

	if (haskey(globals_set, "boot_pmac_custom"))
	{
		globals_set["boot_pmac_custom"] = BootCommon::MountByDev2Dev(globals_set["boot_pmac_custom"]:"");
	}
	
	if (haskey(globals_set, "boot_iseries_custom"))
	{
		globals_set["boot_iseries_custom"] = BootCommon::MountByDev2Dev(globals_set["boot_iseries_custom"]:"");
	}

	if (haskey(globals_set, "boot_prep_custom"))
	{
		globals_set["boot_prep_custom"] = BootCommon::MountByDev2Dev(globals_set["boot_prep_custom"]:"");
	}
	return globals_set;
}

/**
 * Function remap "resume" from section (append) to device name (/dev/sda) 
 * or to label (ufo_partition)
 * @param map<string,any> sections
 * @return map<string,any> sections
 */

define string remapResume(string append)
{
	if ((search(append, "resume")!=nil) && (search(append, "noresume") == nil))
	{
		y2milestone("append before remapping resume: %1", append);
		list <string> list_append = splitstring (append, " ");
		y2debug("split append to list list_append: %1", list_append);
		list <string> new_append = [];

		foreach(string key, list_append,
		{
			if (search(key,"resume") != nil)
			{
				y2debug("arg resume from append: %1",key);
				list <string> resume_arg = splitstring(key, "=");
				string dev = resume_arg[1]:"";
				y2debug("value of resume: %1",resume_arg[1]:"");
				if (dev != "")
				{
					string resume = "resume="+BootCommon::MountByDev2Dev(dev);
					y2debug("remap resume: %1",resume);
					new_append = add(new_append, resume);
				} else {
					y2debug("adding key to new append_list: %1", key);
					new_append = add(new_append, key);
				}
			} else {
				y2debug("adding key to new append_list: %1", key);
				new_append = add(new_append, key);
			}
		});

		y2debug("NEW append list: %1", new_append);
		string ret = mergestring(new_append, " ");
		y2milestone("Append after remaping: %1", ret);
		return ret;

	} else {
		y2milestone("Section hasn't resume...");
		return append;
	}
}

/**
 * Function remap measure in section to autoyast format
 * 
 * @param map<string,string> map of measures $["file": "pcr"]
 * @return list<map<string,string> > list of measures for autoyast format
 */

list <map <string, string> > remapMeasure(map <string, string> measure)
{
	list <map <string, string> > ret = [];
	if (size(measure) >0)
	{
		foreach(string k, string v, measure, 
		{
			map <string, string> tmp_map = $[];
			tmp_map["file"] = k;
			tmp_map["pcr"] = v;
			ret = add(ret,tmp_map);
		});
	}

	return ret;
}


/**
 * Function remap measure in section from autoyast format
 * 
 * @param list<map<string,string> > list of measures [$["file": "/tmp/file1", "pcr" : "8"]]
 * @return map<string,string> map of measures
 */

map <string, string> importMeasure(list<map<string, string> > measure)
{
	map <string, string> ret = $[];
	if (size(measure) >0)
	{
		maplist(map <string, string> m, measure, 
		{
			string file = m["file"]:"";
			string pcr = m["pcr"]:"";
			ret[file]=pcr;
		});
	}

	return ret;
}


/**
 * Function remap section "root" and "resume" to device name (/dev/sda) 
 * or to label (ufo_partition)
 * @param list<map<string,any> > list of sections
 * @return list<map<string,any> > list of sections
 */
global list<map<string,any> > importSections(list<map<string,any> >sec)
{
	y2debug("import section before remapping %1", sec);
	list<map<string,any> >temp_sec = [];
	temp_sec = maplist (map<string,any> s, sec, 
	{
		
		if (haskey(s,"measures"))
		{
			map <string, string> tmp = $[];
			tmp = importMeasure(s["measures"]:[]);
			s = remove(s,"measures");
			if (size(tmp) > 0)
				s["measure"]=tmp;
		}

		return s;
	});
	y2debug("import section after remapping %1", temp_sec);
	return temp_sec;
}




/**
 * Function remap section "root" and "resume" to device name (/dev/sda) 
 * or to label (ufo_partition)
 * it also prepared measured files for export
 * @param list<map<string,any> > list of sections
 * @return list<map<string,any> > list of sections
 */

global list<map<string,any> > remapSections(list<map<string,any> >sec)
{	
	symbol by_mount = nil;
	if (Arch::ppc())
	    by_mount = `id;
        else
	    by_mount = Storage::GetDefaultMountBy();

	//by_mount = `id;
	if (by_mount == `label)
		return sec;

	list<map<string,any> >temp_sec = [];
	
	// convert root and resume device names in sections to kernel device names
	temp_sec = maplist (map<string,any> s, sections, 
	{
		
		if (s["root"]:"" != "")
		{
			string rdev = s["root"]:"";
			s["root"] = BootCommon::MountByDev2Dev(rdev);

			if (s["append"]:"" != "")
				s["append"] = remapResume(s["append"]:"");
		
			y2debug("remapping root: %1 from section to: %2 ",rdev ,s["root"]:"");
		}

		if (s["chainloader"]:"" != "")
			s["chainloader"] = BootCommon::MountByDev2Dev(s["chainloader"]:"");

		if (haskey(s,"measure"))
		{
			list <map <string, string> > tmp =[];
			tmp = remapMeasure(s["measure"]:$[]);
			s = remove(s,"measure");
			if (size(tmp) > 0)
				s["measures"]=tmp;
		}

		return s;
	});

	return temp_sec;
}

/** bnc#687878 - mountby uuid not respected in menu.lst
 * Function check if proposed_partition still includes
 * flag "create"
 *
 * @param map<string,map> tm
 * @return true if partition is still not created
 */

boolean CheckProposedPartition (map<string,map> tm)
{

    boolean ret = true;
    if (!Mode::installation())
    {
	y2debug("Skip CheckProposedPartition() -> it is not running installation");
	return false;
    }
    if (size(tm) == 0 || BootCommon::proposed_partition == "")
    {
	y2debug("proposed_partition is empty: %1", BootCommon::proposed_partition);
	return false;
    }
    map dp = Storage::GetDiskPartition (proposed_partition);
    string disk = dp["disk"]:"";
    list <map> partitions = (list<map>)tm[disk,"partitions"]:[];
    foreach (map p, partitions, 
    {
        if (p["device"]:"" == BootCommon::proposed_partition)
	{
	   if (p["create"]:nil != true)
	   {
	      BootCommon::proposed_partition = "";
	      y2milestone("proposed_partition is already created: %1", p);
	      if (BootCommon::all_devices_created == 1)
		  BootCommon::all_devices_created = 2;
	      if (BootCommon::all_partitions_created == 1)
		  BootCommon::all_partitions_created = 2;
	      ret = false;
	   } else {
	      y2milestone("proposed_partition: %1 is NOT created", BootCommon::proposed_partition);
	   }
	   break;
	}
    });
    return ret;
}

/** bnc#687878 - mountby uuid not respected in menu.lst
 * Check if it is necessary rebuild all_devices
 *
 * @return true -> rebuild all_devices
 */
 
boolean RebuildMapDevices()
{
    boolean ret = false;
    boolean ret_CheckProposedPartition = CheckProposedPartition((map<string,map>)Storage::GetTargetMap());

    if (!ret_CheckProposedPartition && BootCommon::all_devices_created == 2)
	return true;

    return ret;
}
 
/** bnc#687878 - mountby uuid not respected in menu.lst
 * Init and fullfil internal data for perl-Bootloader
 *
 * @return true if init reset/fullfil data or false and used cached data
 */

global boolean InitMapDevices ()
{
	boolean ret = false;
	if (saved_last_change_time_from_storage != Storage::GetTargetChangeTime() || RebuildMapDevices())
	{
		y2milestone("Init internal data from storage");
		MapDevices();
		saved_last_change_time_from_storage = Storage::GetTargetChangeTime();
		ret = true;
	}
	
	return ret;
}
 
/** bnc#687878 - mountby uuid not respected in menu.lst
 * Check if it is necessary rebuild all_partitions and all_disks
 *
 * @return true -> rebuild all_partitions and all_disks
 */

boolean RebuildMapAllPartitions()
{
    boolean ret = false;
    boolean ret_CheckProposedPartition = CheckProposedPartition((map<string,map>)Storage::GetTargetMap());

    if (!ret_CheckProposedPartition && BootCommon::all_partitions_created == 2)
	return true;

    return ret;
}

/**
 * bnc #468922 - problem with longtime running the parsing a huge number of disks
 * Function initialize BootCommon::all_partitions only if storage change 
 * partitioning of disk
 * true if init all_partitions
 */

boolean MapAllPartitions()
{
    boolean ret = false;
    if ((saved_last_change_time_from_storage != Storage::GetTargetChangeTime())
	|| (size(BootCommon::all_partitions) < 1)
	|| (size(BootCommon::target_map) < 1)
	|| RebuildMapAllPartitions())
    {
	// save last change time from storage for MapAllPartitions()
	saved_last_change_time_from_storage = Storage::GetTargetChangeTime();

	BootCommon::all_partitions = $[];
	BootCommon::target_map = $[];
	// get target map
	BootCommon::target_map = (map<string,map>)Storage::GetTargetMap();
	// map all partitions
	foreach (string k, map v, BootCommon::target_map,
	{
		foreach (map p, (list<map>)(v["partitions"]:[]), 
		{
			// bnc#687878 - mountby uuid not respected in menu.lst
			// if there is "not created" partition and flag for "it" is not set
			if ((p["create"]:nil == true) && (Mode::installation()))
			{
			    if (BootCommon::proposed_partition == "")
				BootCommon::proposed_partition = p["device"]:"";
			    BootCommon::all_partitions_created = 1;
			}
			all_partitions[p["device"]:""] = p;
		});
	});
	ret = true;
    }
    if (Mode::installation() && BootCommon::all_partitions_created == 2)
    {
	BootCommon::all_partitions_created = 0;
	y2milestone("set status for all_partitions to \"created\"");
    }

    return ret;
}

/** FATE #302219 - Use and choose persistent device names for disk devices
 * Converts a device name to the corresponding device name it should be
 * mounted by, according to the "mountby" setting for the device from
 * yast2-storage. As a safeguard against problems, if the "mountby" device
 * name does not exist in the information from yast2-storage, it will
 * fallback to the "kernel name" ("/dev/sdXY").
 *
 * @param dev string device name
 * @return string device name according to "mountby"
 */
global define string Dev2MountByDev(string dev) 
{
	y2milestone ("Dev2MountByDev: %1", dev);
	symbol by_mount = nil;

	// add all_partitions to partitions
	if (MapAllPartitions())
	    y2milestone("Init BootCommon::all_partitions was done");

	map<string,map> partitions = BootCommon::all_partitions;
	map<string,map> devices = BootCommon::target_map;
	map partition = $[];
	map device = $[];
	string ret = dev;

	// bnc#510086 mountby-Option "device" from the AutoYast partitioning profile 
        // isnt correctly populating lilo.conf
	// (`id,`uuid,`path,`device,`label)
	// bnc#458018 accept different mount-by for partition
	// created by user
	by_mount = Storage::GetDefaultMountBy();
	//by_mount = `id;
	y2milestone("Default mount by is %1", by_mount);

	if (haskey(partitions, dev))
	{
		symbol partition_mount_by = (symbol) partitions[dev, "mountby"]:nil;
		if ((partition_mount_by != nil))
			by_mount = partition_mount_by;
	}

	if (by_mount == `device)
	{
	    y2milestone("Skip converting device: %1 to persistent device names because mountby is set to: %2",
			dev, by_mount);
	    return dev;
	}

	if (Arch::ppc())
	{
	    by_mount = `id;
	    y2milestone("Adding default mount-by for ppc (`id)");
	}


	switch(by_mount) 
	{
		// convert to udev_id
		case (`id):
			// partitions
			partition = partitions[dev]:$[];
			if ((partition["udev_id"]:nil != nil) && (partition["udev_id", 0]:nil != ""))
			{
				ret = sformat ("/dev/disk/by-id/%1", partition["udev_id", 0]:"");
	   			y2milestone ("Device name: %1 is converted to udev id: %2", dev, ret);
	   			return ret;
			}
			// disks
			device = devices[dev]:$[];
			if ((device["udev_id"]:nil != nil) && (device["udev_id", 0]:nil != ""))
			{
	   			ret = sformat ("/dev/disk/by-id/%1", device["udev_id", 0]:"");
	   			y2milestone ("Device name: %1 is converted to udev id: %2", dev, ret);
	   			return ret;
			}
		break;

		// convert to uuid
		case (`uuid):
			// partitions
			partition = partitions[dev]:$[];
			// watch out for fake uuids (shorter than 8 chars)
			if (size(partition["uuid"]:"") > 8)
			{
	   			ret = sformat ("/dev/disk/by-uuid/%1", partition["uuid"]:"");
	   			y2milestone ("Device name: %1 is converted to uuid: %2", dev, ret);
	   			return ret;
			}
			// disks
			device = devices[dev]:$[];
			if ((device["uuid"]:nil != nil) && (device["uuid"]:nil != ""))
			{
	   			ret = sformat ("/dev/disk/by-uuid/%1", device["uuid"]:"");
	   			y2milestone ("Device name: %1 is converted to uuid: %2", dev, ret);
	   			return ret;
			}
		break;

		// convert to udev_path
		case (`path):
			// partitions
			partition = partitions[dev]:$[];
			if ((partition["udev_path"]:nil != nil) && (partition["udev_path"]:nil != ""))
			{
	   			ret = sformat ("/dev/disk/by-path/%1", partition["udev_path"]:"");
	   			y2milestone ("Device name: %1 is converted to udev path: %2", dev, ret);
	   			return ret;
			}
			// disks
			device = devices[dev]:$[];
			if ((device["udev_path"]:nil != nil) && (device["udev_path"]:nil != ""))
			{
	   			ret = sformat ("/dev/disk/by-path/%1", device["udev_path"]:"");
	   			y2milestone ("Device name: %1 is converted to udev path: %2", dev, ret);
	   			return ret;
			}
		break;

		// convert to label
		case (`label):
			// partitions
			partition = partitions[dev]:$[];
			if ((partition["label"]:nil != nil) && (partition["label"]:nil != ""))
			{
	   			ret = sformat ("/dev/disk/by-label/%1", partition["label"]:"");
	   			y2milestone ("Device name: %1 is converted to label: %2", dev, ret);
	   			return ret;
			}
			// disks
			y2milestone ("Disk doesn't support labels - name: %1 is converted to label: %2", dev, ret);
			return ret;			
		break;

		// convert to device or uknown type
		default:
			y2milestone ("Convert %1 to `device or unknwn type, result: %2", dev, ret);
			return ret;
		break;
	}

	return ret;
}

    /**
     * Returns list of partitions with "mount by" hints. Goes through the list
     * of partitions passed as a parameter and creates a list of partitions with
     * hints according to the current partitioning requested from
     * yast2-storage. To be used in a combobox or menu.
     *
     * @param parts_to_get list<string> partitions to list
     * @return a list of strings containing a partition name and a hint (if applicable)
     */
    global define list<string> getHintedPartitionList(list<string> parts_to_get) ``{
	y2milestone ("getHintedPartitionList: %1", parts_to_get);
	map<string,map> devices = (map<string,map>)Storage::GetTargetMap();

	// make a map: "/dev/hda1" -> info_map_for_this_partition
	map<string,map> partitions = $[];
	foreach (string k, map v, devices, ``{
	    foreach (map p, (list<map>)(v["partitions"]:[]), ``{
		partitions[p["device"]:""] = p;
	    });
	});
	y2milestone ("getHintedPartitionList: partitions %1", partitions);

	symbol mountby = `device;
	list<string> ret = maplist (string dev, parts_to_get, ``{
	    mountby = (symbol) partitions[dev, "mountby"]:nil;
	    if ( mountby == `uuid )
	    {
		// watch out for fake uuids (shorter than 8 chars)
		return sformat ("%1 (mount by UUID: %2)", dev,
				size(partitions[dev, "uuid"]:"") > 8 ?
				partitions[dev, "uuid"]:"" :
				"<UUID to be created later during format>");
	    } else if ( mountby == `label )
	    {
		return sformat ("%1 (mount by LABEL: %2)", dev, partitions[dev, "label"]:"");
	    } else if ( mountby == `id )
	    {
		return sformat ("%1 (mount by ID: %2)", dev, partitions[dev, "udev_id", 0]:"");
	    } else if ( mountby == `path )
	    {
		return sformat ("%1 (mount by PATH: %2)", dev, partitions[dev, "udev_path"]:"");
	    } else if ( mountby == nil || mountby == `device )
	    {
		return dev;
	    }
	});

	y2milestone ("getHintedPartitionList: ret %1", ret);
	return ret;
    }

    /**
     * Returns list of partitions. Requests current partitioning from
     * yast2-storage and creates list of partition for combobox, menu or other
     * purpose.
     * @param type symbol
     *   `boot - for bootloader installation
     *   `root - for kernel root
     *   `boot_other - for bootable partitions of other systems
     *   `all - all partitions
     *   `parts_old - all partitions, except those what will be created
     *      during isntallation
     *   `deleted - all partitions deleted in current proposal
     *   `kept - all partitions that won't be deleted, new created or formatted
     *   `destroyed - all partition which are new, deleted or formatted
     * @return a list of strings
     */
    global define list<string> getPartitionList(symbol type) ``{
	y2milestone ("getPartitionList: %1", type);
	map<string,map> devices = (map<string,map>)Storage::GetTargetMap();
	list<map> partitions = [];
	foreach (string k, map v, devices, ``{
	    partitions = (list<map>)merge (partitions, (list<map>)(v["partitions"]:[]));
	});
	list<string> floppies = getFloppyDevices ();

	devices = filter (string k, map v, devices,
	                  ``(v["type"]:`CT_UNKNOWN != `CT_LVM));

	if (type == `boot || type == `boot_other)
	{
	    devices = filter (string k, map v, devices,
	                      ``(v["type"]:`CT_UNKNOWN == `CT_DISK));
	}
	list<string> all_disks = (list<string>) maplist (string k, map v, devices, ``(k));

	if (type == `deleted)
	    return maplist (map x, filter (map p, partitions, ``(p["delete"]:false)),
		``{return x["device"]:"";
	    });
	else if (type == `destroyed)
	{
	    return maplist (map x, filter (map p, partitions, {
		    return p["delete"]:false || p["format"]:false
			|| p["create"]:false;
		}),
	    {
		return x["device"]:"";
	    });
	}
        partitions = filter (map p, partitions, ``(! p["delete"]:false));
	list<string> ret = all_disks;
	if (type == `boot_other || type == `root || type == `parts_old
	    || type == `kept)
            ret = [];

	if (type == `boot)
        {
	    partitions = filter (map p, partitions,
                ``(p["type"]:`primary == `primary
		    || p["type"]:`primary == `extended
		    || p["type"]:`primary == `logical
		    || p["type"]:`primary == `sw_raid));
	    // FIXME this checking is performed on 3 places, one function should
	    // be developed for it
	    partitions = filter (map p, partitions, {
		symbol fs = (symbol)(p["used_fs"]:p["detected_fs"]:nil);
		if (fs == `xfs)
		    return false;
		return true;
	    });
        }
        else if (type == `root)
        {
            partitions = filter (map p, partitions,
                    ``(p["type"]:`primary != `extended));
        }
	else if (type == `parts_old)
	{
	    partitions = filter (map p, partitions, ``(! p["create"]:false));
	}
	else if (type == `kept)
	{
	    partitions = filter (map p, partitions, {
		return ! (p["create"]:false || p["format"]:false);
	    });
	}
        if (type != `all && type != `parts_old && type != `kept)
        {
            partitions = filter (map p, partitions,
                ``(p["fstype"]:"" != "Linux swap"));
        }
	if (type == `boot)
	{
	    partitions = filter (map p, partitions,
                ``(p["fstype"]:"" == "Linux native"
                    || p["fstype"]:"" == "Extended"
		    || p["fstype"]:"" == "Linux RAID"
		    || tolower(p["fstype"]:"") == "md raid"));
	}
        list<string>partition_names
	    = maplist (map p, partitions, ``((string)(p["device"]:"")));
	partition_names = filter (string p, partition_names, ``(p != ""));
        partition_names = (list<string>)merge (partition_names, floppies);
        ret = (list<string>)union (ret, partition_names);
	ret = (list<string>)toset (ret);
	return (list<string>)ret;
    }

    /**
      * returns true if char is blank (newline, tab or space)
      * @param s single char string
      * @return boolean blank/non blank
      */
    global define boolean isBlank(string s) ``{
	if (s == "\n" || s == "\t" || s == " ")
	{
	    return true;
	}
	return false;
    }

    /**
      * removes trailing and leading blank chars from string.
      *   eg: "  as df  " -> "as df"
      * @param str string source string
      * @return string stripped string
      */
    define string strip(string str)``{
	//emtpy  string
	if (size(str) == 0) return "";

	integer bound = size(str);
	integer first = 0;
	integer last = size(str) - 1;
	// find first non-blank char
	while(first < bound && isBlank(substring(str, first, 1)))
	{
	    first = first + 1;
	}

	while(last >= 0 && isBlank(substring(str, last, 1)))
	{
	    last = last - 1;
	}
	if (last >= first)
	{
	    return substring(str, first, last - first + 1);
	}
	return "";
    }

    /**
      * replaces all occurences of 'from' to 'to' in src
      * @param src input string
      * @param from string to be replaced
      * @param to string to be replaced by
      * @return string modified string
      */
    global define string replaceAll(string src, string from, string to) ``{
	if (from == "")
	{
	    return src;
	}

	list tokens = [];

	integer p = search(src, from);
	while(p != nil)
	{
	    tokens = add(tokens, substring(src, 0, p));
	    src = substring(src, p + size(from), size(src) - (p+size(from)));
	    p = search(src, from);
	}
	tokens = add(tokens, src);
	return mergestring((list<string>)tokens, to);
    }

    /**
      * convert string values from agent representation to module representation
      * 1) if string is quoted, quotes are removed
      * 2) if string contains escaped quotes, they're unescaped
      * @param val value to transform
      * @return any transformed value
      */
    global define any mod2ui(any val) ``{
	if (is(val, string))
	{
	    string v = sformat("%1", val);
	    v = strip(v);
	    // remove leading and trailing quotes
	    if (substring(v, 0, 1) == "\""
		&& substring(v, size(v)-1, 1) == "\"")
	    {
		v = substring(v, 1, size(v)-2);
	    }

	    // unescape backslashes
	    v = replaceAll(v, "\\\\", "\\");

	    // unescape quotes
	    v = replaceAll(v, "\\\"", "\"");
	    return v;
	}
	return val;
    }

    /**
      * returns list difference A \ B (items that are in A and are not in B)
      * @param a list A
      * @param b list B
      * @return list see above
      */
    list difflist(list a, list b) ``{
	return filter(any e, a, ``(!contains(b, e)));
    }


    /**
      * returns modified list where items index1 and index2 are swapped.
      * if indices are out of bounds, unmodified list is returned.
      * @param input list
      * @param index1 index of the first element
      * @param index2 index og the second element
      * @return list modified list
      */
    global define list swapItems(list input, integer index1, integer index2) ``{
	if (index1 >= size(input) || index2 >= size(input)
	    || index1 < 0 || index2 < 0)
	{
	    return input;
	}
	list output = [];
	integer pos = -1;
	output = maplist(any e, input, {
	    pos = pos + 1;
	    if (pos == index1)
	    {
	        return (any)(input[index2]:(any)$[]);
	    }
	    else if (pos == index2)
	    {
	        return (any)(input[index1]:(any)$[]);
	    }
	    return e;
	});
	return output;
    }

    /**
      * translate filename path (eg. /boot/kernel) to list of device
      *  and relative path
      * @param fullpth string fileststem path (eg. /boot/vmlinuz)
      * @return a list containing device and relative path,
      *  eg. ["/dev/hda1", "/vmlinuz"]
      */
    global define list<string> splitPath (string fullpth) ``{
// UGHLY HACK because of testsuites
	map<string,list> mountpoints = $[];
	if (Mode::test ())
	    mountpoints = $["/" : ["/dev/hda2"], "/boot" : ["/dev/hda1"]];
	else
	    mountpoints = (map<string,list>)Storage::GetMountPoints();
	string dev = "";
	string mp = "";
	integer max = 0;
	//
	// FIXME: this is broken code, implement a proper prefix match!! see below
	foreach (string k, list v, mountpoints, ``{
	    if (k != "swap" && issubstring (fullpth, k) && size (k) > max)
	    {
	        max = size (k);
	        dev = v[0]:"";
	        mp = k;
	    }
	});
	if (mp == "")
	    return [];

	// FIXME: pth will be wrong for fullpth=='(hd0,1)/boot/vmlinux' !!
	string pth = substring (fullpth, size (mp));
	if (substring (pth, 0, 1) != "/")
	    pth = "/" + pth;
	return [dev, pth];
    }

    /**
      * Get bootloader device for specified location
      * FIXME: this function is being phased out. Keeping it around until
      * selected_location and loader_device can be dropped for all bootloader
      * types.
      * @return string device name
      */
    global define string GetBootloaderDevice () ``{
        if (BootCommon::selected_location == "mbr")
            return BootCommon::mbrDisk;
        if (BootCommon::selected_location == "boot")
	    return BootCommon::BootPartitionDevice;
        if (BootCommon::selected_location == "root")
	    return  BootCommon::RootPartitionDevice;
        if (BootCommon::selected_location == "floppy")
            return StorageDevices::FloppyDevice();
        if (BootCommon::selected_location == "mbr_md")
	    return "mbr_md";
	if (BootCommon::selected_location == "none")
	    return "/dev/null";
        return BootCommon::loader_device;
    }

    /**
      * Get list of bootloader device names for all selected or specified
      * locations
      * @return list device names
      */
    global define list<string> GetBootloaderDevices () ``{
	list<string> ret = [];
	if (BootCommon::globals["boot_boot"]:"false" == "true") {
	    ret = add(ret, BootCommon::BootPartitionDevice);
	}
	if (BootCommon::globals["boot_root"]:"false" == "true") {
	    ret = add(ret, BootCommon::RootPartitionDevice);
	}
	if (BootCommon::globals["boot_mbr"]:"false" == "true") {
	    ret = add(ret, BootCommon::mbrDisk);
	}
// FIXME: `mbr_md is probably unneeded; AFA we can see, this decision is
// automatic anyway and perl-Bootloader should be able to make it without help
// from the user or the proposal.
//	if (BootCommon::globals["boot_mbr_md"]:"false" == "true") {
	    // FIXME: make this work; this code was copied from
	    // BootGRUB::Save(), where it was commented out (changes in
	    // perl-Bootloader are pending)
	    // get the list of device names to install the boot loader stage 1 into:
	    //   - for non-md devices, use just the device name
	    //   - for installation to md arrays: get the list of device names from
	    //     name of md array, either
	    //	     - just the container-partitions (according to yast2-storage) or
	    //         ("/dev/md0" -> ["/dev/hda1", ...])
	    //       - the (cut off) name of the corresponding disk devices
	    //         ("/dev/md0" -> ["/dev/hda1", ...] -> ["/dev/hda", ...])
	//     list<list<string> > dev_lists = maplist (string d, loader_devices, {
	// 	if (substring (d, 0, 7) == "/dev/md")
	// 	{
	// 	    map<string,integer> md = BootCommon::Md2Partitions (d);
	// 	    if (Mode::test ())
	// 		md = $["/dev/hda1" : 128, "/dev/hdb1" : 129];
	// 	    return maplist (string d, integer b, md, {
	// 		return d;
	// 	    });
	// 	}
	// 	if (d == "mbr_md")
	// 	{
	// 	    map<string,integer> md = BootCommon::Md2Partitions
	// 		(BootCommon::BootPartitionDevice);
	// 	    if (Mode::test ())
	// 		md = $["/dev/hda1" : 128, "/dev/hdb1" : 129];
	// 	    return maplist (string d, integer b, md, {
	// 		// get disk device name for this partition or disk device name
	// 		map p_dev = Storage::GetDiskPartition (d);
	// 		return p_dev["disk"]:"";
	// 	    });
	// 	}
	// 	return [d];
	//     });
	    // ret = add(ret, BootCommon::mbrDisk);
//	}
	if ( haskey(BootCommon::globals, "boot_extended") &&
	    BootCommon::globals["boot_extended"]:"false" == "true" ) {
	    ret = add(ret, BootCommon::ExtendedPartitionDevice);
	}
	// FIXME: floppy support is probably obsolete
	if ( haskey(BootCommon::globals, "boot_floppy") &&
	    BootCommon::globals["boot_floppy"]:"false" == "true" ) {
	    ret = add(ret, StorageDevices::FloppyDevice());
	}
	if ( haskey(BootCommon::globals, "boot_custom") ) {
	    ret = add(ret, BootCommon::globals["boot_custom"]:"");
	}
	if ( size(ret) > 0 )
	    return ret;
	// FIXME: find out what the best value is here: nil, [] or ["/dev/null"]
	return ["/dev/null"];
    }

/**
 * Check if the PBR of the given partition seems to contain a known boot block
 * @param device string partition device to check
 * @return true if the PBR seems to contain a known boot block
 */
global boolean IsPartitionBootable (string device) {
    // use examine_mbr.pl to analyze PBR (partition boot record):
    // examine_mbr.pl prints "* stage1" when it finds the signature
    // of some stage1 bootloader
    // (The exit code would tell us only whether we should
    // (re-)install a bootloader stage1 there in order to make the
    // partition bootable, not whether a stage1 already exists.)
    map result = (map)SCR::Execute (.target.bash_output, sformat (
	"/usr/lib/YaST2/bin/examine_mbr.pl %1", device));
    y2milestone ("PBR examining script returned %1", result);
    return search(result["stdout"]:"", "stage1") != nil ? true : false;
}


/**
 * Check if installation to floppy is performed
 * @return true if installing bootloader to floppy
 */
global boolean InstallingToFloppy () {
    boolean ret = false;

    y2milestone("InstallingToFloppy: loader_device = %1", loader_device);

    if (loader_device == nil || loader_device == "")
	ret = false;
    // bnc #180784 don't install to bootloader to floppy if ppc
    else if (getLoaderType (false) == "ppc")
	ret = false;
    else if (loader_device == StorageDevices::FloppyDevice())
	ret = true;
    else if (contains (getFloppyDevices (), loader_device))
	ret = true;

    y2milestone ("Installing to floppy: %1", ret);

    return ret;
}


/**
 * Get the list of particular kernel parameters
 * @param line string the whole kernel command line
 * @return a list of the kernel parameters split each separaterlly
 */
list<string> ListKernelParamsInLine (string line) {
// FIXME this function is really similar to code in Kernel.ycp
    list<string> cmdlist = [];
    integer parse_index = 0;
    boolean in_quotes = false;
    boolean after_backslash = false;
    string current_param = "";
    while (parse_index < size (line))
    {
	string current_char = substring (line, parse_index, 1);
	if (current_char == "\"" && ! after_backslash)
	    in_quotes = ! in_quotes;
	if (current_char == " " && ! in_quotes)
	{
	    cmdlist = add (cmdlist, current_param);
	    current_param = "";
	}
	else
	    current_param = current_param + current_char;
	if (current_char == "\\")
	    after_backslash = true;
	else
	    after_backslash = false;
	parse_index = parse_index + 1;
    }
    cmdlist = add (cmdlist, current_param);
    cmdlist = maplist (string c, cmdlist, {
	if (regexpmatch (c, "^[^=]+="))
	    c = regexpsub (c, "^([^=]+)=", "\\1");
	return c;
    });
    return cmdlist;

}

    /**
      * get kernel parameter from kernel command line
      * @param line string original line
      * @param key string parameter key
      * @return string value, "false" if not present,
      *   "true" if present key without value
      */
    global define string getKernelParamFromLine (string line, string key) ``{
	// FIXME this doesn't work with quotes and spaces
	string res = "false";
	list<string> params = splitstring (line, " ");
	params = filter (string p, params, ``(p != ""));
	foreach (string p, params, ``{
	    list<string> l = (list<string>) filter (string e, splitstring (p, "="), ``(e != " " && e != ""));
	    if (l[0]:"" == key)
	        res = l[1]:"true";
	});
	return res;
    }

    /**
      * set kernel parameter to GRUB command line
      * @param line string original line
      * @param key string parameter key
      * @param value string value, "false" to remove key,
      *   "true" to add key without value
      * @return string new kernel command line
      */
    global define string setKernelParamToLine
	(string line, string key, string value)
    ``{
	// FIXME this doesn't work with quotes and spaces
	list<string> params = splitstring (line, " ");
	params = filter (string p, params, ``(p != ""));
	boolean done = false;
	// count occurences of every parameter
	map<string,integer> occurences = $[];
	foreach (string p, params, ``{
	    list<string> l = filter (string e, splitstring (p, "="), ``(e != " " && e != ""));
	    string k = l[0]:"";
	    occurences[k] = occurences[k]:0 + 1;
	});
	params = maplist (string p, params, ``{
	    list<string> l = filter (string e, splitstring (p, "="), ``(e != " " && e != ""));
	    string k = l[0]:"";
	    if (k == key)
	    {
		if (value == "false")
		{
		    return "";
		}
		else if (occurences[k]:0 <= 1)
		{
	            done = true;
		    if (value == "true")
		    {
			return key;
		    }
		    else if (value != "false")
		    {
			return sformat ("%1=%2", key, value);
		    }
		}
		else
		{
		    occurences[k] = occurences[k]:0 - 1;
		    return "";
		}
	    }
	    return p;
	});
	if (! done)
	{
	    if (value == "true")
	    {
	        params = add (params, key);
	    }
	    else if (value != "false")
	    {
	        params = add (params, sformat ("%1=%2", key, value));
	    }
	}
	params = filter (string p, params, ``(p != ""));
	line = mergestring (params, " ");
	return line;
    }


    /*
     *  convert any value to an integer and return 0 for nonsense
     */
    global integer myToInteger(any num_any) {
	if (num_any == nil)
	    return 0;
	if (is (num_any, integer))
	    return (integer)num_any;
	if (is (num_any, string))
	    return (num_any == "") ? 0 :
		(tointeger((string)num_any) == nil ? 0 : tointeger((string)num_any));
	return 0;
    }

    /**
      * Get partition which should be activated if doing it during bl inst.
      * @param boot_partition string the partition holding /boot subtree
      * @param loader_device string the device to install bootloader to
      * @return a map $[ "dev" : string, "mbr": string, "num": any]
      *  containing device (eg. "/dev/hda4"), disk (eg. "/dev/hda") and
      *  partition number (eg. 4)
      */
    map<string,any> getPartitionToActivate (string boot_partition,
	string loader_device)
    {
	map p_dev = Storage::GetDiskPartition (loader_device);
	integer num = myToInteger( p_dev["nr"]:nil );
	string mbr_dev = p_dev["disk"]:"";

	// if bootloader is installed to /dev/md*
	// FIXME: use ::storage to detect md devices, not by name!
	if (substring (loader_device, 0, 7) == "/dev/md")
	{
	    map<string,integer> md = Md2Partitions (BootCommon::loader_device);
	    integer min = 256; // max. is 255; 256 means "no bios_id found"
	    string device = "";
	    foreach (string d, integer id, md, {
		if (id < min)
		{
		    min = id;
		    device = d;
		}
	    });
	    if (device != "")
	    {
		map p_dev = Storage::GetDiskPartition (device);
		num = myToInteger( p_dev["nr"]:nil );
		mbr_dev = p_dev["disk"]:"";
	    }
	}
	// if bootloader in MBR, activate /boot partition
	// (partiall fix of #20637)
	else if (num == 0)
	{
	    p_dev = Storage::GetDiskPartition (boot_partition);
	    num = myToInteger( p_dev["nr"]:nil );
	    mbr_dev = p_dev["disk"]:"";

	    if (size (Md2Partitions (boot_partition)) > 1)
	    {
		foreach (string k, integer v, Md2Partitions (boot_partition),{
		    if (search (k, loader_device) == 0)
		    {
			p_dev = Storage::GetDiskPartition (k);
			num = myToInteger( p_dev["nr"]:nil );
			mbr_dev = p_dev["disk"]:"";
		    }
		});
	    }
	}
	if (num != 0)
	{
	    if (num > 4)
	    {
		y2milestone ("Bootloader partition type is logical");
		map tm = Storage::GetTargetMap ();
		list<map> partitions = tm[mbr_dev, "partitions"]:[];
		foreach (map p, partitions, ``{
		    if (p["type"]:nil == `extended)
		    {
			num = p["nr"]:num;
			y2milestone ("Using extended partition %1 instead",
			num);
		    }
		});
	    }
	}
	map<string,any> ret = $[
	    "num" : num,
	    "mbr" : mbr_dev,
	    "dev" : Storage::GetDeviceName (mbr_dev, num),
	];
	return ret;
    }

    /**
     * Get a list of partitions to activate if user wants to activate
     * boot partition
     * @return a list of partitions to activate
     */
    list<map<string, any> > getPartitionsToActivate () {
	map<string,integer> md = $[];
	if (BootCommon::loader_device == "mbr_md")
	{
	    md =  Md2Partitions (BootCommon::BootPartitionDevice);
	}
	else
	{
	    md =  Md2Partitions (BootCommon::loader_device);
	}
	list<string> partitions = maplist (string k, integer v, md, ``(k));
	if (size (partitions) == 0)
	{
	    partitions = [BootCommon::loader_device];
	}
	list<map<string,any> > ret = maplist (string partition, partitions, {
	    return getPartitionToActivate (
		BootCommon::BootPartitionDevice,
		partition);
	});
	return toset (ret);
    }

    /**
     * Get the list of MBR disks that should be rewritten by generic code
     * if user wants to do so
     * @return a list of device names to be rewritten
     */
    list<string> getMbrsToRewrite () {
	list<string> ret = [BootCommon::mbrDisk];
	map<string,integer> md = $[];
	if (BootCommon::loader_device == "mbr_md")
	{
	    md =  Md2Partitions (BootCommon::BootPartitionDevice);
	}
	else
	{
	    md = Md2Partitions (BootCommon::loader_device);
	}
	list<string> mbrs = maplist (string d, integer b, md, {
	    d = getPartitionToActivate (
		BootCommon::BootPartitionDevice, d
	    )["mbr"]:mbrDisk;
	    return d;
	});
	if (contains (mbrs, BootCommon::mbrDisk))
	{
	    ret = (list<string>)merge (ret, mbrs);
	}
	return toset (ret);
    }

    /**
      * Get last change time of file
      * @param filename string name of file
      * @return string last change date as YYYY-MM-DD-HH-MM-SS
      */
     string getFileChangeDate (string filename) {
	map stat = (map) SCR::Read (.target.stat, filename);
	integer ctime = stat["ctime"]:0;
	string command = sformat (
	  "date --date='1970-01-01 00:00:00 %1 seconds' +\"%%Y-%%m-%%d-%%H-%%M-%%S\"",
	  ctime);
	map out = (map) SCR::Execute (.target.bash_output, command);
	string c_time = out["stdout"]:"";
	y2debug ("File %1: last change %2", filename, c_time);
	return c_time;
    }

    /**
      * Save current MBR to /boot/backup_mbr
      * Also save to /var/lib/YaST2/backup_boot_sectors/%device, if some
      * existing, rename it
      * @param device string name of device
      */
    void saveMBR (string device) {
	string device_file = mergestring (splitstring (device, "/"), "_");
	string device_file_path = "/var/lib/YaST2/backup_boot_sectors/"
	    + device_file;
	string device_file_path_to_logs = "/var/log/YaST2/"
	    + device_file;
	SCR::Execute (.target.bash,
	    "test -d /var/lib/YaST2/backup_boot_sectors || mkdir /var/lib/YaST2/backup_boot_sectors");
	if (SCR::Read (.target.size, device_file_path) > 0)
	{
	    list<string> contents = (list<string>) SCR::Read (.target.dir, "/var/lib/YaST2/backup_boot_sectors");
	    contents = filter (string c, contents, ``(regexpmatch (c, sformat (
		"%1-.*-.*-.*-.*-.*-.*", device_file))));
	    contents = sort (contents);
	    integer index = 0;
	    integer siz = size (contents);
	    while (index + 10 < siz)
	    {
		SCR::Execute (.target.remove,
		    sformat ("/var/lib/YaST2/backup_boot_sectors/%1", contents[index]:""));
		index = index + 1;
	    }
	    string change_date = getFileChangeDate (device_file_path);
	    SCR::Execute (.target.bash, sformat (
		"/bin/mv %1 %1-%2",
		device_file_path, change_date));
	}
	SCR::Execute (.target.bash, sformat (
	    "/bin/dd if=%1 of=%2 bs=512 count=1 2>&1",
	    device, device_file_path));
        // save MBR to yast2 log directory
	SCR::Execute (.target.bash, sformat (
	    "/bin/dd if=%1 of=%2 bs=512 count=1 2>&1",
	    device, device_file_path_to_logs));

	if (device == mbrDisk)
	{
	    SCR::Execute (.target.bash, sformat (
		"/bin/dd if=%1 of=%2 bs=512 count=1 2>&1",
		device, "/boot/backup_mbr"));

    	    // save thinkpad MBR 
	    if (ThinkPadMBR(device))
	    {
	       string device_file_path_thinkpad = device_file_path + "thinkpadMBR";
	       y2milestone("Backup thinkpad MBR");
	       SCR::Execute(.target.bash, sformat (
	       "cp %1 %2 2>&1", device_file_path, device_file_path_thinkpad));
	    }
	}
    }

    /**
      * Update contents of MBR (active partition and booting code)
      * FIXME move tis function to lilolike.ycp
      * @return boolean true on success
      */
    global define boolean updateMBR () ``{
      	// FIXME: do the real thing in perl_Bootloader
      	if (getLoaderType (false) == "grub") {  
      	    activate = ( globals["activate"]:"false" == "true" );
      	    repl_mbr = ( globals["generic_mbr"]:"false" == "true" );
      	}

	y2milestone ("Updating disk system area, activate partition: %1, replace MBR: %2", activate, repl_mbr);
	if (backup_mbr)
	{
	    y2milestone ("Doing MBR backup: MBR Disk: %1, loader device: %2",
		BootCommon::mbrDisk, BootCommon::loader_device);
	    list<string> disks_to_rewrite = (list<string>)toset (merge (
		getMbrsToRewrite (),
		[BootCommon::mbrDisk, BootCommon::loader_device]));
	    y2milestone ("Creating backup of boot sectors of %1",
		disks_to_rewrite);
	    foreach (string d, disks_to_rewrite, {
		saveMBR (d);
	    });
	}
	boolean ret = true;
	// if the bootloader stage 1 is not installed in the MBR, but
	// ConfigureLocation() asked us to replace some problematic existing
	// MBR, then overwrite the boot code (only, not the partition list!) in
	// the MBR with a generic (currently DOS?) bootloader
	if (repl_mbr && BootCommon::loader_device != mbrDisk)
	{
	    if (! Stage::initial ())
	    {
		PackageSystem::Install ("master-boot-code");
	    }
	    y2milestone("Updating code in MBR: MBR Disk: %1, loader device: %2",
		BootCommon::mbrDisk, BootCommon::loader_device);
	    list<string> disks_to_rewrite = getMbrsToRewrite ();
	    foreach (string d, disks_to_rewrite, {
		y2milestone ("Copying generic MBR code to %1", d);
		// added fix 446 -> 440 Vista booting problem bnc # 396444
		string command = sformat (
		    "/bin/dd bs=440 count=1 if=%1 of=%2",
		    "/usr/lib/boot/master-boot-code",
		    d);
		y2milestone ("Running command %1", command);
		map out = (map)SCR::Execute (.target.bash_output, command);
		integer exit = out["exit"]:0;
		y2milestone ("Command output: %1", out);
		ret = ret && (0 == exit);
	    });
	}

	if (activate)
	{
	  foreach (map m_activate, getPartitionsToActivate (), {
	    any num = m_activate["num"]:0;
	    string mbr_dev = m_activate["mbr"]:"";
	    if (num != 0 && mbr_dev != "")
	    {
		// if primary partition
		if ((! is (num, integer)) || num <= 4)
		{
		    y2milestone ("Activating partition %1 on %2", num, mbr_dev);
		    // FIXME: this is the most rotten code since molded sliced bread
		    // move to bootloader/Core/GRUB.pm or similar
		    // TESTME: make sure that parted does not destroy BSD
		    // slices (#suse24740): cf. section 5.1 of "info parted":
		    //   Parted only supports the BSD disk label system.
		    //   Parted is unlikely to support the partition slice
		    //   system in the future because the semantics are rather
		    //   strange, and don't work like "normal" partition tables
		    //   do.
//		    string command = sformat
//			("/usr/sbin/parted -s %1 set %2 boot on", mbr_dev, num);
		    // As a workaround for #167602, moved back to
		    // /sbin/activate, because it does not cause the kernel to
		    // forget about an activated extended partition (it changes
		    // the data on disk without using any ioctl).
		    // FIXME: investigate proper handling of the activate flag
		    // (kernel ioctls in parted etc.) and fix parted
		    string command = sformat
			("/usr/sbin/parted -s %1 set %2 boot on", mbr_dev, num);
		    y2milestone ("Running command %1", command);
		    map out = (map)SCR::Execute (.target.bash_output, command);
		    integer exit = out["exit"]:0;
		    y2milestone ("Command output: %1", out);
		    ret = ret && (0 == exit);
		}
	    }
	    else
	    {
		y2error ("Cannot activate %1", m_activate);
	    }
	  });
	}
	return ret;
    }

    /**
      * Rewrite current MBR with /var/lib/YaST2/backup_boot_sectors/%device
      * Warning!!! don't use for bootsectors, 440 bytes of sector are written
      * @param device string device to rewrite MBR to
      * @return boolean true on success
      */
    global define boolean restoreMBR (string device) ``{
	string device_file = mergestring (splitstring (device, "/"), "_");
	if (SCR::Read (.target.size, sformat ("/var/lib/YaST2/backup_boot_sectors/%1", device_file))
	    <= 0)
	{
	    Report::Error ("Can't restore MBR. No saved MBR found");
	    return false;
	}
        // added fix 446 -> 440 for Vista booting problem bnc #396444
	integer ret = (integer) SCR::Execute (.target.bash, sformat (
	    "/bin/dd of=%1 if=/var/lib/YaST2/backup_boot_sectors/%2 bs=440 count=1",
	    device, device_file));
	return (ret == 0);
    }

    /**
      * Translate device name to major/minor number
      * @param device string
      * @return string major*256+minor hexadecimal without leading 0x, in case
      *  of any fail return unchanged device node
      */
    string dev2majmin (string device) {
	map exec_ret = (map) SCR::Execute (.target.bash_output, sformat (
	    "ls -ln %1", device));
	if (exec_ret["exit"]:1 != 0 && Stage::initial ())
	{
	    exec_ret = (map) WFM::Execute (.local.bash_output, sformat (
		"ls -ln %1", device));
	}
	if (exec_ret["exit"]:1 != 0)
	    return device;
        string ls = exec_ret["stdout"]:"";
        list<string> parts = splitstring (ls, " ");
        parts = filter (string p, parts, ``(p != ""));
        string majs = parts[4]:"";
        majs = substring (majs, 0, size (majs) -1);
        string mins = parts[5]:"";
	if (majs == "" || majs == nil || mins == "" || mins == nil)
	    return device;
        integer maj = tointeger (majs);
        integer min = tointeger (mins);
	majs = tohexstring (maj);
	majs = substring (majs, 2);
	while (size (majs) < 2)
	    majs = "0" + majs;
	mins = tohexstring (min);
	mins = substring (mins, 2);
	while (size (mins) < 2)
	    mins = "0" +  mins;
	y2debug ("Translated %1 to %2:%3", device, majs, mins);
	string ret = sformat ("%1%2", majs, mins);
        return ret;
    }


    /**
      * Update kernel parameters if some were added in Kernel module
      * @param orig original kernel parameters or kernel command line
      * @return kernel command line or parameters with added new parameters
      */
    global define string UpdateKernelParams (string orig) ``{
	list<string> new = splitstring (Kernel::GetCmdLine (), " ");
	list<string> old = splitstring (orig, " ");
	list<string> added = (list<string>)difflist (new,
	     splitstring (BootCommon::kernelCmdLine, " "));
	added = (list<string>)difflist (added, old);
	old = (list<string>) merge (old, added);
	if (Stage::initial ())
	{// move showopts apic to the end
	    boolean showopts = false;
	    boolean apic = false;
	    if (contains (old, "showopts"))
		showopts = true;
	    if (contains (old, "apic"))
		apic = true;
	    old = filter (string o, old, ``(o != "apic" && o != "showopts"));
	    if (showopts)
		old = add (old, "showopts");
	    if (apic)
		old = add (old, "apic");
	}
	return mergestring (old, " ");
    }


    /**
      * Get map of swap partitions
      * @return a map where key is partition name and value its size
      */
    global define map<string, integer> getSwapPartitions () ``{
	map<string, map> tm = (map<string,map>)Storage::GetTargetMap ();
	boolean installation = Mode::installation ();
	map<string, integer> ret = $[];
	foreach (string k, map v, tm, ``{
	    integer cyl_size = v["cyl_size"]:0;
	    list<map<string,any> > partitions = v["partitions"]:[];
	    partitions = filter(map<string,any> p, partitions, {
		return p["mount"]:"" == "swap" && ! p["delete"]:false;
	    });
	    foreach (map<string, any> s, partitions, ``{
		string dev = (string)(s["device"]:"");
		ret[dev] = (integer)(s["region", 1]:0) * cyl_size;
	    });
	});
	y2milestone ("Available swap partitions: %1", ret);
	return ret;
    }

    

    /**
      * Create translated name of a section
      * @param orig string original section name
      * @return translated section name
      */
    global define string translateSectionTitle (string orig) ``{
	return GfxMenu::translateSectionTitle(orig,
					      getLoaderType(false));
    }

    /**
      * Check if device is MBR of a disk
      * @param device string device to check
      * @return boolean true if is MBR
      */
    define boolean IsMbr (string device) ``{
	if (regexpmatch (device, "^\/dev\/[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]+$"))
	    return true;
	if (regexpmatch (device, "^\/dev\/[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]+\/.*d[0-9]+$"))
	    return true;
	return false;
    }

    /**
      * Add '(MBR)' to the disk description if it is a MBR of some partition
      * @param descr string disk description
      * @param device string disk device
      * @return string updated description
      */
    define string AddMbrToDescription (string descr, string device) ``{
	return IsMbr (device)
	    ? sformat ("%1 (MBR)", descr)
	    : descr;
    }

    /**
     * Update the Kernel::vgaType value to the saved one if not defined
     */
    global define void UpdateInstallationKernelParameters () ``{
	map<string,any> saved_params = $[];
	if (! Stage::initial ())
	{
	    saved_params = (map<string,any>)SCR::Read (
		.target.ycp, "/var/lib/YaST2/bootloader.ycp");
	}
	if (Kernel::GetVgaType () == "")
	{
	    string vgaType = (string)(saved_params["vga"]:"");
	    if (vgaType != nil && vgaType != "")
		Kernel::SetVgaType (vgaType);
	}
	if (! Stage::initial ())
	{
	    Kernel::SetCmdLine (saved_params["installation_kernel_params"]:"");
	}
	else
	{
	    if (SCR::Read (.etc.install_inf.NoPCMCIA) == "1")
	    {
		Kernel::SetCmdLine (Kernel::GetCmdLine () + " NOPCMCIA");
	    }
	}
    }

    /**
     * Get additional kernel parameters
     * @return additional kernel parameters
     */
    global define string GetAdditionalFailsafeParams () ``{
	if (Stage::initial ())
	{
	    additional_failsafe_params =
		SCR::Read (.etc.install_inf.NoPCMCIA) == "1"
		    ? " NOPCMCIA "
		    : "";
	}
	else
	{
	    map<string,any> saved_params = (map<string,any>)SCR::Read (
		.target.ycp, "/var/lib/YaST2/bootloader.ycp");
	    additional_failsafe_params
		= saved_params["additional_failsafe_params"]:"";
	}
	return additional_failsafe_params;
    }

/**
 * Get additional kernel parameters from control file
 * @return string additional kernel parameters
 */
global string GetAdditionalKernelParams () {
    return ProductFeatures::GetStringFeature (
		"globals",
		"additional_kernel_parameters");
}

/**
 * Get additional kernel parameters splitted to a list
 * @return a list of additional kernel parameters
 */
global list<string> ListAdditionalKernelParams () {
    return ListKernelParamsInLine (GetAdditionalKernelParams ());
}

/**
 * Update graphical bootloader to contain help text of current language
 * And make the selected installation language default
 * @return boolean true on success
 */
global define boolean UpdateGfxMenuContents () {
    return GfxMenu::UpdateGfxMenuContents(getLoaderType(false));
}


/**
 * Update device name according to changes in kernel (eg. SATA)
 * @param device string the original device name
 * @return string updated device
 */
global string UpdateDevice (string device) {
    if (Mode::test ())
    {
	map mapping = $[
	    "/dev/hda" : "/dev/sda",
	    "/dev/hdb" : "/dev/sdb",
	];

	map d = Storage::GetDiskPartition( device );
	if( haskey( mapping, d["disk"]:"" ))
	{
	    if (d["nr"]:nil == nil || d["nr"]:nil == 0)
	    {
		device = mapping[d["disk"]:""]:"";
	    }
	    else
	    {
		device = Storage::GetDeviceName(
		    mapping[d["disk"]:""]:"",
		    d["nr"]:nil);
	    }
	}
    }
    else
    {
	list<string> devices = Storage::GetTranslatedDevices (
	    installed_version,
	    update_version,
	    [ device ]);
	device = devices[0]:device;
    }
    return device;
}

/**
 * Check if memtest86 is present
 * @return boolean true if memtest86 section is to be proposed
 */
global boolean MemtestPresent () {
    return (! contains (removed_sections, "memtest"))
	&& (Mode::test ()
	    || (Mode::normal () && Pkg::IsProvided ("memtest86+"))
	    || (! Mode::normal () && Pkg::IsSelected ("memtest86+")));

}


/**
 * Check if the bootloader can be installed at all with current configuration
 * @return boolean true if it can
 */
global boolean BootloaderInstallable () {
    if (Mode::config ())
	return true;
    if (Arch::i386 () || Arch::x86_64 ())
    // the only relevant is the partition holding the /boot filesystem
    {
	DetectDisks ();
	string loader = BootCommon::getLoaderType (false);
	boolean is_efi = loader == "elilo" || loader == "grub2-efi";

        // FIXME: what about using getBootPartition() ???
	string boot_partition = is_efi ? BootCommon::BootEFIPartitionDevice : BootCommon::BootPartitionDevice;

	y2milestone ("Boot partition device: %1", boot_partition);
	map dev = Storage::GetDiskPartition( boot_partition );
	y2milestone ("Disk info: %1", dev);
	// MD, but not mirroring is OK
	// FIXME: type detection by name deprecated
	if (dev["disk"]:"" == "/dev/md")
	{
	    map tm = Storage::GetTargetMap ();
	    map md = tm["/dev/md"]:$[];
	    list<map> parts = md["partitions"]:[];
	    map info = $[];
	    foreach (map p, parts, {
		if (p["device"]:"" == boot_partition)
		    info = p;
	    });
	    if (tolower (info["raid_type"]:"") != "raid1")
	    {
		y2milestone ("Cannot install bootloader on RAID (not mirror)");
		return false;
	    }

	    // (bnc 357897) - lilo reports inconsistent raid version when trying to install on raid1
	    if (getLoaderType (false) == "lilo")
	    {
		string raid_ver = info["sb_ver"]:"";    //"00.90.03"
		if (substring(raid_ver,0,2) == "01")
		{
		    y2milestone ("Cannot install bootloader on RAID (lilo doesn't support raid version %1)", info["sb_ver"]:"");
		    return false;
		}
	    }
	}
	// EVMS
	// FIXME: type detection by name deprecated
	else if (search (boot_partition, "/dev/evms/") == 0)
	{
	    y2milestone ("Cannot install bootloader on EVMS");
	    return false;
	}
	// LVM
	else if (! is( dev["nr"]:(any)0, integer ))
	{
	    y2milestone ("Cannot install bootloader on LVM");
	    return false;
	}

	return true;
    }
    else
    {
	return true;
    }
}
/**
 * Function return boot disk device with udev id name
 * @return string name of boot disk like udev id
 */
define string BootDeviceToUdevID()
{
    string device = "";
    if ((BootPartitionDevice != "") || (BootPartitionDevice != nil))
	device = BootPartitionDevice;

    if (device == "")
	device = RootPartitionDevice;

    if (device == "")
	return device;

    y2milestone("Boot device is: %1", device);
    map p_dev = Storage::GetDiskPartition (device);

    string boot_disk = p_dev["disk"]:"";

    device = Dev2MountByDev(boot_disk);
    y2milestone("Boot disk is %1 and his udev id is: %2", boot_disk, device);
    return device;
}


/**
 * Function handle console from sections 
 * write it to sysconfig if it used
 * @param string console value
 * @return string console value
 */
string writeConsoleToSysconf(string console)
{
	string ret = "";
	if (console != "")
	{
		ret = console;
	}

	return ret;
}


/**
 * Function handle measure from sections 
 * write it to sysconfig if it used
 * @param map <string, string> of measure value
 * @return string measure split with ":"
 */
string writeMeasureToSysconf(map <string, string> measure)
{
	string ret = "";
	foreach(string file, string pcr, measure, {
		ret = ret + file +":";
		ret = ret + pcr + ":";
	});
	if (ret != "")
	    ret = substring(ret, 0, (size(ret) -1));
	return ret;
}

/**
 * Function return absolute value of arg
 *
 * @param integer value
 * @return integer absolute value
 */

integer abs(integer value)
{
	if (value < 0)
		return (value * (-1));
	else
		return value;
}

/**
 * Fuction delete " " on the beginning of string
 *
 */

string delete_white_space(string temp)
{
	string ret = temp;
	while (findfirstof(temp," ") == 0)
	{
		temp = substring(temp, 1);

	}
	ret = temp;
	return temp;
}


/** bnc #440125 - default boot section with failsafe args
 * Compare append from default linux section with append from 
 * BootCommon::sections
 *
 * @return boolean true if appends are similar
 */
boolean compareAppends(string default_append, string section_append)
{
	integer deuce = 0;
	// delete white space on the beginning of string
	default_append = delete_white_space(default_append);
	section_append = delete_white_space(section_append);
	// check valid append for section
	if (size(section_append) < 3)
		return false;

	// check size of default append with section append
	// if the size is same return true (same appends)
	y2milestone("Size of default append: \"%1\" and compared section append: \"%2\"", 
			size(default_append), size(section_append));
	if (size(default_append) == size(section_append))
		return true;

	list <string> default_list = splitstring(default_append, " ");
	list <string> section_list = splitstring(section_append, " ");

	integer size_default_list = size(default_list);
	integer size_section_list = size(section_list);

	integer relative_deuce = abs(size_section_list - size_default_list);

	// check number of append args
	// if different between number of args is more than 3 args return false

	y2milestone("No. default args: %1 no. compared section args: %2", size_default_list, size_section_list);
	if (relative_deuce >= 3)
		return false;

	// check args by keywords from section append to default append

	y2milestone("default_append: %1", default_append);
	y2milestone("section_list: %1", section_list);
	foreach(string key, section_list,
	{		
		if (search(key, "resume=") != nil)
		{
			list <string> tmp = splitstring(key,"=");
			key = Dev2MountByDev(tmp[1]:"");
		}
		if (search(default_append, key) != nil)
			deuce = deuce +1;
		else
			deuce = deuce -1;
	});

	// if there exist more than 3 different args return false
	// else append seem to be similar -> true
	y2milestone("No. deuces of default append with compared append: %1", deuce);
	if (abs(size_default_list - deuce) >= 3)
		return false;
	else
		return true;
}



/** bnc #440125 - default boot section with failsafe args
 * Try to find potencional default linux section
 * It can solve problem in function WriteToSysconf() with saving
 * wrong (failsafe) args for default
 *
 * @return string name of default boot section
 */

global string findRelativeDefaultLinux ()
{
	string default_linux = "";
	
	// create defualt sections
	map<string,any> linux_default = BootCommon::CreateLinuxSection("linux");

	foreach(map<string,any>s, BootCommon::sections,
	{
		if ((s["root"]:"" == linux_default["root"]:nil) &&
		    (s["original_name"]:"" == "linux"))
		{
			if (compareAppends(linux_default["append"]:"", s["append"]:""))
				default_linux = s["name"]:"";
		}
	});

	y2milestone("Relative default boot section is: \"%1\"", default_linux);
	return default_linux;
} 



/** bnc #440125 - default boot section with failsafe args
 * Check if default boot name is linux
 * 
 * @param string default boot name
 * @return boolean true if boot name is linux
 */
global boolean isDefaultBootSectioLinux(string default_boot)
{
	boolean ret = false;
	foreach(map<string,any>s, BootCommon::sections,
	{
		if (s["name"]:"" == default_boot)
		{
			if (s["original_name"]:"" == "linux")
				ret = true;
			break;
		}
	});
	if (ret)
		y2milestone("Boot section: \"%1\" is linux", default_boot);
	else
		y2warning("Boot section: \"%1\" is NOT linux", default_boot);
	return ret;
}

/** bnc #578545 - kdump misconfigures crashkernel parameter for Xen
 * Check if default_append includes crashkernel arg
 * 
 * @param string defaul_append
 * @return string defaul_append without crashkernel
 */

define string deleteCrashkernelFromAppend (string append)
{
	y2milestone("Original append: %1",append);
	list<string> list_append = splitstring(append, " ");

	if (size(list_append)>0)
	{
	   list_append = filter(string key, list_append,
	   {
		if (search(key, "crashkernel") == nil)
		    return true;
		else
		    return false;
           });
	}
	string ret = mergestring(list_append, " ");
	y2milestone("Filtered append: %1",ret);
	return ret;
}


/** FATE #302245 save kernel args etc to /etc/sysconfig/bootloader
 * Function write/update info in /etc/sysconfig/bootloader
 * @param booloean true if it called from inst_bootloader.ycp 
 */

global define void WriteToSysconf(boolean inst_bootloader)
{
    string lt = BootCommon::getLoaderType (false);
    y2milestone ("Saving /etc/sysconfig/bootloader for %1", lt);

    string default_boot_section_name = "";
    // fix for bnc #440125 - default boot section with failsafe args
    // it is not possible create exact algoritmus but I hope it helps in
    // mostly cases.
    default_boot_section_name = BootCommon::checkZiplDefault(BootCommon::globals["default"]:"");
    if (!isDefaultBootSectioLinux(default_boot_section_name))
    {
	default_boot_section_name = findRelativeDefaultLinux ();
    }

    // get the default and failsafe append + vga parameters; if section with
    // appropriate original name not found, just use any Linux section
    // doing so during update may be questionable, however, the variables need to
    // be initialized in any case
    string default_vga = "";
    string default_append = "";
    string default_measure = "";
    string imagepcr = "";
    string initrdpcr = "";
    string console = "";
    boolean default_set = false;
    string failsafe_vga = "";
    string failsafe_append = "";
    string failsafe_measure = "";
    boolean failsafe_set = false;
    string xen_vga = "";
    string xen_append = "";
    string xen_imagepcr = "";
    string xen_initrdpcr = "";
    string xen_measure = "";
    string xenpcr = "";
    string xen_kernel_append = "";
    string addon_name = "";
    string addon_append = "";
    string addon_vga = "";
    boolean xen_set = false;

    // default boot section is not found
    if (default_boot_section_name == "")
    {
	// create defualt sections
	map<string,any> linux_default = BootCommon::CreateLinuxSection("linux");
	default_set = true;
	default_vga = linux_default["vgamode"]:"";
	default_append = linux_default["append"]:"";
    }

    foreach (map<string,any>s, BootCommon::sections, 
    {
	if ((search(s["original_name"]:"","linux") != nil) && 
	   (s["name"]:"" == default_boot_section_name))
	{
	   default_set = true;
	   default_vga = s["vgamode"]:"";
	   console = writeConsoleToSysconf(s["console"]:"");
	   if (haskey(s,"imagepcr"))
		imagepcr = s["imagepcr"]:"";

	   if (haskey(s,"initrdpcr"))
		initrdpcr = s["initrdpcr"]:"";

	   if (haskey(s,"measure"))
		default_measure = writeMeasureToSysconf(s["measure"]:$[]);


	   default_append = s["append"]:"";
    	}
    	if (search(s["original_name"]:"","xen") != nil)
    	{
	   xen_set = true;
	   xen_vga = s["vgamode"]:"";
	   xen_append = s["xen_append"]:"";
	   xen_kernel_append = s["append"]:"";
	   console = writeConsoleToSysconf(s["console"]:"");
	   if (haskey(s,"measure"))
		xen_measure = writeMeasureToSysconf(s["measure"]:$[]);
	   if (haskey(s,"imagepcr"))
		xen_imagepcr = s["imagepcr"]:"";

	   if (haskey(s,"initrdpcr"))
		xen_initrdpcr = s["initrdpcr"]:"";

    	   if (haskey(s,"xenpcr"))
		xenpcr = s["xenpcr"]:"";
	}
    	else if (search(s["original_name"]:"","failsafe") != nil)
    	{
	   failsafe_set = true;
	   failsafe_vga = s["vgamode"]:"";
	   failsafe_append = s["append"]:"";
	   console = writeConsoleToSysconf(s["console"]:"");
	   if (haskey(s,"measure"))
		failsafe_measure = writeMeasureToSysconf(s["measure"]:$[]);
    	}
    	if (s["type"]:"" == "image" && ! default_set)
    	{
	   default_vga = s["vgamode"]:"";
	   default_append = s["append"]:"";
	   console = writeConsoleToSysconf(s["console"]:"");
	   if (haskey(s,"imagepcr"))
		imagepcr = s["imagepcr"]:"";

	   if (haskey(s,"initrdpcr"))
		initrdpcr = s["initrdpcr"]:"";

	   if (haskey(s,"measure"))
		default_measure = writeMeasureToSysconf(s["measure"]:$[]);

    	}
    	if (s["type"]:"" == "image" && ! failsafe_set)
        {
	   failsafe_vga = s["vgamode"]:"";
	   failsafe_append = s["append"]:"";
	   console = writeConsoleToSysconf(s["console"]:"");
	}

	if (s["__rt_kernel"]:"" == "true")
	{
	   addon_name = s["name"]:"";
	   addon_append = s["append"]:"";
	   addon_vga = s["vgamode"]:"";
	}

    });

    if (! xen_set)
    {
       xen_kernel_append = deleteCrashkernelFromAppend(default_append);
       xen_append = "";
       xen_vga = default_vga;
    }

    // save some sysconfig variables
    // register new agent pointing into the mounted filesystem
    path sys_agent = .sysconfig.bootloader;

    if (inst_bootloader)
    {
	WFM::Execute(.local.mkdir, Installation::destdir + "/etc/sysconfig");
	WFM::Execute(.local.bash, sformat ("touch %1/etc/sysconfig/bootloader", Installation::destdir));
	string target_sysconfig_path = Installation::destdir + "/etc/sysconfig/bootloader";
	SCR::RegisterAgent (.target.sysconfig.bootloader, `ag_ini(
  	     `SysConfigFile(target_sysconfig_path)));

	sys_agent = add(.target, sys_agent);

    } 

    SCR::Write (add(sys_agent,.LOADER_TYPE), lt);
    SCR::Write (add(sys_agent,.DEFAULT_NAME), default_boot_section_name);
    SCR::Write (add(sys_agent,.DEFAULT_APPEND), default_append);
    SCR::Write (add(sys_agent,.DEFAULT_VGA), default_vga);
    SCR::Write (add(sys_agent,.FAILSAFE_APPEND), failsafe_append);
    SCR::Write (add(sys_agent,.FAILSAFE_VGA), failsafe_vga);
    SCR::Write (add(sys_agent,.XEN_KERNEL_APPEND), xen_kernel_append);
    SCR::Write (add(sys_agent,.XEN_APPEND), xen_append);
    SCR::Write (add(sys_agent,.XEN_VGA), xen_vga);
    if (console != "")
	SCR::Write (add(sys_agent,.CONSOLE), console);
    if (imagepcr != "")
	SCR::Write (add(sys_agent,.IMAGEPCR), imagepcr);
    if (initrdpcr != "")
	SCR::Write (add(sys_agent,.INITRDPCR), initrdpcr);
    if (xenpcr != "")
	SCR::Write (add(sys_agent,.XEN_PCR), xenpcr);
    if (xen_initrdpcr != "")
	SCR::Write (add(sys_agent,.XEN_INITRDPCR), xen_initrdpcr);

    if (xen_imagepcr != "")
	SCR::Write (add(sys_agent,.XEN_IMAGEPCR), xen_imagepcr);

    if (default_measure != "")
	SCR::Write (add(sys_agent,.DEFAULT_MEASURE), default_measure);

    if (failsafe_measure != "")
	SCR::Write (add(sys_agent,.FAILSAFE_MEASURE), failsafe_measure);
    if (xen_measure != "")
	SCR::Write (add(sys_agent,.XEN_MEASURE), xen_measure);

    if (addon_name != "")
	SCR::Write (add(sys_agent,.RT_NAME), addon_name);

    if (addon_vga != "")
	SCR::Write (add(sys_agent,.RT_VGA), addon_vga);

    if (addon_append != "")
	SCR::Write (add(sys_agent,.RT_APPEND), addon_append);

    SCR::Write (sys_agent, nil);


}

/**
 *
 * FIXME: what is the difference to using BootCommon::BootPartitionDevice directly ???
 *
 * Function return boot device it means
 * return boot partition or root partition if boot partition deosn't exist
 * function return "" if boot partition or root partition is not defined (autoyast)
 * @return string name of boot device (partition)
 */

global string getBootPartition()
{
	string boot_device = "";
	if (BootCommon::BootPartitionDevice != "")
		boot_device = BootCommon::BootPartitionDevice;
	else if (BootCommon::RootPartitionDevice != "")
		boot_device = BootCommon::RootPartitionDevice;

	return boot_device;
}

/** FATE #303548 - Grub: limit device.map to devices detected by BIOS Int 13
 * Function select boot device - disk
 *
 * @return string name of boot device - disk
 */

global string getBootDisk()
{
	string boot_device = getBootPartition();

	if (boot_device == "")
	{
		y2milestone("BootPartitionDevice and RootPartitionDevice are empty");
		return boot_device;
	}
	map p_dev = Storage::GetDiskPartition (boot_device);

	string boot_disk_device = p_dev["disk"]:"";

	if ((boot_disk_device != "") && (boot_disk_device != nil))
	{
		y2milestone("Boot device - disk: %1", boot_disk_device);
		return boot_disk_device;
	}

	y2milestone("Finding boot disk failed!");
	return "";
}

/** FATE #303548 - Grub: limit device.map to devices detected by BIOS Int 13
 * Function select boot device - disk
 *
 * @return string name of boot device - disk
 */


/** FATE #110038: Serial console
 * Function build value for console from:
 * @param string unit no of console 
 * @param string speed
 * @param string parity (n,o,e)
 * @param string word (8)
 * @return string value of console for kernel append
 */
define string buildConsoleValue (string unit, string speed, string parity, string word)
{
	string ret = "";
	if ((unit != "") && (speed != ""))
	{
		// add number of serial console
		ret = "ttyS" + unit;
		// add speed
		ret = ret + "," + speed;
		if (parity != "")
		{
			// add parity
			switch (parity)
			{
				case ("no"):
					ret = ret + "n";
					break;
				case ("odd"):
					ret = ret +"o";
					break;
				case ("even"):
					ret = ret + "e";
					break;
				default:
					ret = ret + "n";
					break;
			}

			// add word
			if (word != "")
				ret = ret + word;
		}
		y2milestone("console value for kernel: %1", ret);
	} else {
		y2error("Wrong values unit: %1 , speed: %2 , parity: %3 , word: %4",
			unit, speed, parity, word);
	}
	return ret;
}


/** FATE #110038: Serial console
 * Function parse string key (e.g. --speed=9600)
 * and return value of key
 * @param string key e.g. --unit=0
 * @return string value of key
 */


define string getKeyValue(string key)
{
	string ret = "";
		list <string> value = [];
		if (key != "")
		{
			value = splitstring (key, "=");
			if (value[1]:"" != "")
				ret = value[1]:"";
		}
	
	y2debug("parse: %1 and return value: %2", key, ret);
	return ret;
}


/** FATE #110038: Serial console
 * Function check value from globals (serial and terminal)
 * after that build value of console append for kernel if it is possible
 * @return string value of console for kernel append
 */

define string getConsoleValue()
{
	string ret = "";
	if ((globals["serial"]:"" != "") && (globals["terminal"]:"" != ""))
	{
		list <string>  list_serial = splitstring (globals["serial"]:"", " ");
		y2milestone("list of serial args: %1", list_serial);
		string unit = "";
		string speed = "";
		string parity = "";
		string word = "";
		foreach(string key, list_serial,
		{
			if (search(key, "--unit") != nil)
				unit = getKeyValue(key);
			
			if (search(key, "--speed") != nil)
				speed = getKeyValue(key);

			if (search(key, "--parity") != nil)
				parity = getKeyValue(key);

			if (search(key, "--word") != nil)
				word = getKeyValue(key);	

		});
		// build value
		ret = buildConsoleValue (unit, speed, parity, word);
	}

	return ret;
}

/** FATE #110038: Serial console
 * Add console arg for kernel if there is defined serial console
 * - add key console with value to section type image and xen
 */

define void addConsole()
{
	string console_value = getConsoleValue();
	if ((console_value != "") && (console_value != nil))
	{
		
		// list of idexes from sections where is image or xen
		list < integer > list_index =[];
		// counter 
		integer index = -1;
		foreach(map<string,any> section, sections,
		{
			index = index +1;
			if ((section["type"]:"" == "image") || (search(section["type"]:"", "xen") != nil))
				list_index = add(list_index, index);
		});

		// add key console with value
		if (size(list_index) > 0)
		{
			foreach (integer idx, list_index,
			{
				sections[idx, "console"] = console_value;
				sections[idx, "__changed"] = true;
				if (sections[idx, "append"]:nil != nil)
				{
					string updated_append = 
						BootCommon::UpdateSerialConsole(sections[idx,"append"]:"",
								 sections[idx,"console"]:"");
					if (updated_append != nil)
					{
						sections[idx,"append"]=updated_append;
					}
				}
				y2debug("Added console for section: %1", sections[idx]:$[]);
			});
		}

	}
}

/** bnc #447591, 438243, 448110 multipath wrong device map
 * Function maps real devices to multipath e.g.
 * "/dev/sda/" : "/dev/mapper/SATA_ST3120813AS_3LS0CD7M"
 *
 * @return map <string, string> mapping real disk to multipath
 */

map <string, string> mapRealDevicesToMultipath()
{
	map <string, string> ret = $[];
	map<string, map> tm = (map<string,map>)Storage::GetTargetMap ();
	integer num_of_real_disk = 0;
	foreach (string disk, map disk_info, tm,
	{
		if (disk_info["type"]:nil == `CT_DMMULTIPATH)
		{
			list <string> devices = (list <string>) disk_info["devices"]:[];
			if (size(devices) > 0)
			{
				foreach(string d, devices,
				{
					ret[d]=disk;
				});

			}
		}

		if (disk_info["type"]:nil == `CT_DISK)
			num_of_real_disk = num_of_real_disk +1;
		if (disk_info["bios_id"]:nil != nil)
			bois_id_missing = false;
	});
	if (num_of_real_disk == 1)
		bois_id_missing = false;
	return ret;
}

/** bnc #450153 - support for installation kernel from add-on
 * fucntion call client from add-on and update proposal for 
 * yast2-bootloader. -> availabe edit kernel args for kernel
 * from add-on
 *
 * @return boolean - true on success
 */
global boolean UpdateProposalFromClient ()
{
	boolean ret = true;
	string client_file = "kernel_bl_proposal";
	if ((!Arch::i386()) && (!Arch::x86_64()))
	{
		y2milestone("Unsuported architecture... for adding SLERT addon");
		return ret;
	}

	if (WFM::ClientExists(client_file))
	{
		y2milestone("Client: %1 was found", client_file);
		WFM::CallFunction (client_file, []);
	
	} else {
		y2milestone("File %1 doesn't exist - proposal will not be updated", client_file);
	}

	return ret;
}





} //end of include
