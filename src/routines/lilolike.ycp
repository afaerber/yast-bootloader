/**
 * File:
 *      include/bootloader/routines/lilolike.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Functions common for lilo-like bootloaders only
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *      Olaf Dabrunz <od@suse.de>
 *
 * $Id$
 *
 */
{

textdomain "bootloader";

import "Arch";
import "Mode";
import "Storage";
import "StorageDevices";
import "BootArch";
import "Map";

global string DiskOrderSummary ();
global list<string> DisksOrder ();
global void DetectDisks ();
global void ProposeDeviceMap ();
global boolean DisksChanged ();

include "bootloader/routines/i386.ycp";

/**
 * Is embedding 1.5 stage of bootloader to dedicated partition area possible?
 * @return true if it is possible
 */
// FIXME: remove this function, it is obsolete (now handled within grub by
// using "setup" instead of "install")
// The code probably does not work with multiple bootloader locations anyway.
// Keeping this temporarily until no other code references it anymore (so that
// for now, the code compiles). This is only used from widget code, and that
// code is probably obsolete as well.
// This code previously existed in lilolike.ycp and in grub/misc.ycp...
global boolean allowEmbed15 () {
    // allow only if /boot, /root or MBR device selected
    // (corrected anyway to use boot_* keys; only grub knows about embed_1.5)
    if (! (BootCommon::globals["boot_boot"]:"false" == "true"
	 || BootCommon::globals["boot_root"]:"false" == "true"
	 || BootCommon::globals["boot_mbr"]:"false" == "true"
    ))
    {
	return false;
    }
    // check filesystem on /boot for Reiserfs and JFS
    map mp = Storage::GetMountPoints ();
    list bp_info
	= mp["/boot"]:mp["/"]:[];
    list<map> partitions
	= Storage::GetTargetMap ()[bp_info[2]:"", "partitions"]:[];
    boolean ret = false;
    foreach (map p, partitions, {
	if (p["device"]:"" == BootCommon::BootPartitionDevice)
	{
	    symbol fs = (symbol)p["used_fs"]:nil;
	    if (fs == `reiser || fs == `jfs)
		ret = true;
	}
    });
    return ret;
}
/**
 * Check whether disk settings were changed since last checking
 * @return boolean true if needs to recheck
 */
global boolean DisksChanged () {
    if (Mode::config ())
	return false;
    map mp = Storage::GetMountPoints();
    string actual_root = mp["/", 0]:"";
    string actual_boot = mp["/boot", 0]:actual_root;

    // don't change configuration if '/' and '/boot' were not changed
    // and location is "floppy", "mbr" or "boot"
    if (actual_boot == BootCommon::BootPartitionDevice
	&& actual_root == BootCommon::RootPartitionDevice
            && selected_location != "custom"
            && selected_location != ""
	    && selected_location != nil)
    {
	return false;
    }

    list all_partitions = BootCommon::getPartitionList(`boot);

    if (!contains(all_partitions, BootCommon::loader_device))
    {
	y2milestone ("Location should be set again");
	return true;
    }
    return false;
}

/**
 * FindMbrDisk()
 * try to find the system's mbr device
 * @return string   mbr device
 */
global string FindMBRDisk() {
    y2milestone("FindMBRDisk: current MBR = %1", BootCommon::mbrDisk);

    // check the disks order, first has MBR
    list<string> order = DisksOrder ();
    if (size (order) > 0)
    {
	string ret = order[0]:"";
	y2milestone ("FindMBRDisk: using first disk, new MBR = %1", ret);
	return ret;
    }

    // OK, order empty, use the disk with boot partition
    map mp = Storage::GetMountPoints();
    string boot_disk = mp["/boot",2]:(mp["/",2]:"");
    y2milestone ("FindMBRDisk: using disk with /boot, new MBR = %1", boot_disk);
    return boot_disk;
}



/**
 * function check all partitions and it tries to find /boot partition
 * if it is MD Raid and soft-riad return correct device for analyse MBR
 * @param list<map> list of partitions
 * @return string device for analyse MBR
 */
define string soft_MDraid_boot_disk(list<map> partitions)
{
   string result = "";
   string boot_device = "";
   if ((BootCommon::BootPartitionDevice != nil) && (BootCommon::BootPartitionDevice != ""))
       boot_device = BootCommon::BootPartitionDevice;
   else
       boot_device = BootCommon::RootPartitionDevice;

   foreach(map p, partitions, {
	if (p["device"]:"" == boot_device)
	{
	   if ((p["type"]:nil == `sw_raid) && (tolower(p["fstype"]:"") == "md raid"))
	   {
	      string device_1 = p["devices",0]:"";
	      y2debug("device_1: %1", device_1);
	      map dp = Storage::GetDiskPartition (device_1);
	      y2debug("dp: %1", dp);
	      result = dp["disk"]:"";
	   }
	}
   });
   y2milestone("Device for analyse MBR from soft-raid (MD-Raid only): %1", result);
   return result;
}



    /**
     * ConfigureLocation()
     * Where to install the bootloader.
     * Returns the type of device where to install: one of "boot", "root", "mbr", "mbr_md"
     * Also sets internal global variable selected_location to this.
     *
     * Sets internal global variables:
     *	    - selected_location	to the type of bootloader device (currently one of: "boot", "root", "mbr", "mbr_md")
     *	    - loader_device	to the actual device name to install the bootloader to (e.g. "/dev/hda1") or to "mbr_md"
     *	    - activate		to true if the loader_device needs to be activated in the MBR
     *      - activate_changed	leave untouched, except when
     *				    - booting from a primary /boot partition on the first disk (the one with the MBR seen by the BIOS), then set to true
     *				      (FIXME: why only then?)
     *	    - repl_mbr		leave untouched, except when
     *				    - booting from a primary /boot partition on the first disk, then set to true when
     *					- the examination of the code in the MBR
     *					    - by examine_mbr.pl shows that it
     *						- DOES NOT look like a valid "stage 1" at all (not enough entropy to contain valid code)	    OR
     *						- DOES NOT look like a "generic MBR" (= DOS MBR) (OK as stage 1 to boot primary part. on 1st disk)  OR
     *						- DOES     look like a LILO or GRUB MBR (replace them with generic code
     *							   (if stage 1 is not in MBR, see code in updateMBR()),
     *							   they probably contain an obsolete block list for stage 2)				    OR
     *						- DOES     look like some "stage 1" code (has enough entropy, but no known signature)		    OR
     *					    - by KeepMBR() -> ThinkPadMBR() shows that it
     *						- DOES NOT look like a Thinkpad MBR (begins with specific code sequence from that one)
     *				      otherwise set to false
     *
     * @return string type of location proposed to bootloader
     */
     // FIXME: replace with grub_ConfigureLocation() when lilo et al. have
     // changed to stop using selected_location and loader_device.
    string ConfigureLocation() {
        selected_location = "mbr";             // default to mbr
        loader_device   = BootCommon::mbrDisk;
	// check whether the /boot partition
	//  - is primary:			    is_logical	-> false
	//  - is on the first disk (with the MBR):  disk_is_mbr -> true
	map<string,any> tm = Storage::GetTargetMap ();
	map dp = Storage::GetDiskPartition (BootPartitionDevice);
	string disk = dp["disk"]:"";
	boolean disk_is_mbr = disk == mbrDisk;
	map dm = tm[disk]:$[];
	list<map> partitions = dm["partitions"]:[];
	boolean is_logical = false;
	string extended = nil;
	list<string> needed_devices = [ BootPartitionDevice ];
	map<string,integer> md_info = Md2Partitions (BootPartitionDevice);
	if (md_info != nil && size (md_info) > 0)
	{
	    disk_is_mbr = false;
	    needed_devices = maplist (string d, integer b, md_info, {
		map pdp = Storage::GetDiskPartition (d);
		string p_disk = pdp["disk"]:"";
		if (p_disk == mbrDisk)
		    disk_is_mbr = true;
		return d;
	    });
	}
	y2milestone ("Boot partition devices: %1", needed_devices);
	foreach (map p, partitions, {
	    if (p["type"]:nil == `extended)
	    {
		extended = (string)p["device"]:nil;
	    }
	    else if (contains (needed_devices, p["device"]:"")
	        && p["type"]:nil == `logical)
	    {
		is_logical = true;
	    }
	});
	y2milestone ("/boot is on 1st disk: %1", disk_is_mbr);
	y2milestone ("/boot is in logical partition: %1", is_logical);
	y2milestone ("The extended partition: %1", extended);

	// keep_mbr, if the MBR contains special code that needs to be kept,
	//           like Thinkpad boot code (and ATM only Thinkpad boot code
	//           is recognized)
	boolean keep_mbr = KeepMBR (loader_device);

	integer exit = 0;
	// if is primary, store bootloader there
	if (disk_is_mbr && ! is_logical)
	{
	    selected_location = "boot";
	    loader_device = BootPartitionDevice;
	    activate = true;
	    activate_changed = true;
	    // examine_mbr.pl returns
	    //	    - != 0 (errno, e.g. 2) for a read error: "cannot read 512
	    //	           bytes from <dev>"
	    //	    - 254  for an "invalid MBR", i.e. without enough entropy to
	    //	           contain boot code
	    //	    - 254    for a "Generic MBR" (DOS MBR) - bnc #438752
	    //	    - 254  for a GRUB or lilo "stage 1"
	    //	    - 254  for an unknown MBR
            //	    - 0    for a Vista MBR
	  
            
            // check if there is raid and if it soft-raid select correct device for analyse MBR
            // bnc #398356
	    if (size (needed_devices) > 1)
	       disk = soft_MDraid_boot_disk(partitions);
	    if (disk == "")
	       disk = dp["disk"]:"";

	    map out = (map)SCR::Execute (.target.bash_output, sformat (
		"/usr/lib/YaST2/bin/examine_mbr.pl %1", disk));
	    y2milestone ("MBR examining script returned %1", out);
	    exit = out["exit"]:0;
	    repl_mbr = (exit == 254) && (! keep_mbr);

	}
	else if (size (needed_devices) > 1)
	{
	    loader_device = "mbr_md";
	    selected_location = "mbr_md";
	}

	if (keep_mbr)
	{
	    if (is_logical && extended != nil)
		loader_device = extended;
	    else
		loader_device = BootPartitionDevice;
	    selected_location = "boot";
	}
	if (! contains (getPartitionList (`boot), loader_device))
	{
	    selected_location = "mbr";             // default to mbr
	    loader_device   = BootCommon::mbrDisk;
	}

        y2milestone ("ConfigureLocation (%1 on %2)",
	    selected_location, loader_device);

	// set active flag
	if (selected_location == "mbr")
	{
	    // we are installing into MBR:
	    // if there is an active partition, then we do not need to activate
	    // one (otherwise we do)
            activate = size (Storage::GetBootPartition (mbrDisk)) == 0;
	}
	else
	{
	    // if not installing to MBR, always activate
	    activate = true;
	}

        return selected_location;
    }

    /**
      * Detect /boot and / (root) partition devices
      * If loader_device is empty or the device is not available as a boot
      * partition, also calls ConfigureLocation to configure loader_device, set
      * selected_location and set the activate flag if needed
      * all these settings are stored in internal variables
      */
    global void DetectDisks () {
	// #151501: AutoYaST needs to know the activate flag and the
	// loader_device; jsrain also said this code is probably a bug:
	// commenting out, but this may need to be changed and made dependent
	// on a "clone" flag (i.e. make the choice to provide minimal (i.e. let
	// YaST do partial proposals on the target system) or maximal (i.e.
	// stay as closely as possible to this system) info in the AutoYaST XML
	// file)
	// if (Mode::config ())
	//    return;
        map mp = Storage::GetMountPoints();

	list mountdata_root = mp["/"]:[];
        list mountdata_boot = mp["/boot"]:mountdata_root;
	list mountdata_boot_efi = mp["/boot/efi"]:mountdata_boot;

        y2milestone( "mountPoints %1", mp );
        y2milestone( "mountdata_boot %1", mountdata_boot );
        y2milestone( "mountdata_boot_efi %1", mountdata_boot_efi );

        BootCommon::RootPartitionDevice = mountdata_root[0]:"";

        if (BootCommon::RootPartitionDevice == "")
        {
            y2error ("No mountpoint for / !!");
        }

        // if /boot changed, re-configure location
        BootCommon::BootPartitionDevice = mountdata_boot[0]:BootCommon::RootPartitionDevice;

        BootCommon::BootEFIPartitionDevice = mountdata_boot_efi[0]:BootCommon::BootPartitionDevice;

	if (BootCommon::mbrDisk == "" || BootCommon::mbrDisk == nil)
	{
	    // mbr detection.
	    BootCommon::mbrDisk = FindMBRDisk();
	}

	if (loader_device == nil || loader_device == ""
	    || ! contains (getPartitionList (`boot), loader_device))
            ConfigureLocation ();

    }

    /**
      * Converts the md device to the list of devices building it
      * @param md_device string md device
      * @return a map of devices (from device name to BIOS ID or nil if
      *   not detected) building the md device
      */
    global define map<string, integer> Md2Partitions (string md_device) {
	map<string,integer> ret = $[];
	map<string,any> tm = (map<string,map>)Storage::GetTargetMap();
	foreach (string disk, any descr_a, tm, ``{
	    map<string,any> descr = (map<string,any>)descr_a;
	    string bios_id_str = descr["bios_id"]:"";
	    integer bios_id = 256; // maximum + 1 (means: no bios_id found)
	    if (bios_id_str != "")
		bios_id = tointeger (bios_id);
	    list<map<string,any> > partitions = (list<map<string,any> >)
		descr["partitions"]:[];
            y2milestone ("Md2Partitions: md_device = %1, bios_id = %2, partitions = %3", md_device, bios_id, partitions);
	    foreach (map<string,any> partition, partitions, ``{
                if (
                    partition["used_by_type"]:`UB_NONE == `UB_MD &&
                    partition["used_by_device"]:"" == md_device
                ) {
		    string d = partition["device"]:"";
		    ret[d] = bios_id;
		}
	    });
	});
	y2milestone ("Partitions building %1: %2", md_device, ret);
	return ret;
    }

    /**
      * Converts the md device to the first of its members
      * @param md_device string md device
      * @return string one of devices building the md array
      */
    global define string Md2Partition (string md_device) {
	map<string,integer> devices = Md2Partitions (md_device);
	if (size (devices) == 0)
	    return md_device;
	integer minimal = 129; // maximum + 2
	string found = "";
	foreach (string k, integer v, devices, {
	    if (v < minimal)
	    {
		found = k;
		minimal = v;
	    }
	});
	return found;
    }


/**
 * Run delayed updates
 *
 * This is used by perl-Bootloader when it cannot remove sections from the
 * bootloader configuration from the postuninstall-script of the kernel. It
 * writes a command to a delayed update script that is then called here to
 * remove these sections.
 *
 * The script is deleted after execution.
 */
global void RunDelayedUpdates () {
    string scriptname = "/boot/perl-BL_delayed_exec";
    string cmd = sformat("test -x %1 && { cat %1 ; %1 ; }", scriptname);

    y2milestone ("running delayed update command: %1", cmd);
    map out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("command returned %1", out);

    cmd = sformat("rm -f %1", scriptname);
    out = (map)SCR::Execute (.target.bash_output, cmd);
}


/**
 * fallback list for kernel flavors (adapted from Kernel.ycp), used if we have
 * no better information
 * order is from special to general, but prefer "default" in favor of "xen"
 */
// FIXME: handle "rt" and "vanilla"?
// bnc #400526 there is not xenpae anymore...
list<string> generic_fallback_flavors = [
	"s390", "iseries64", "ppc64", "bigsmp", "default", "xen",
];

/**
 * Fix global section of lilo-like bootloader
 *
 * This currently only tries to fix the "default" key if necessary. It is when
 * the referenced section does not exist anymore or during a system update when
 * a special comment in the bootloader configuration tells us that we have to
 * update the "default" key. An empty "default" value is not changed, because
 * this means that no default is wanted.
 *
 * If we need to fix the "default" key we take the following steps:
 *
 *  - If we are fixing the configuration at the end of an update and the
 *    special key "former_default_image_flavor" exists, try to set the default
 *    to the first "linux.*" section with an image of this flavor (preferring
 *    "linux" entries over possibly older "linux-.*" entries).
 *
 *  - Otherwise go through a list of fallback kernel flavours and use the first
 *    "linux.*" section that contains a matching image (preferring "linux"
 *    entries over possibly older "linux-.*" entries).
 *
 *  - Otherwise, simply use the first section as the default section.
 */
global void FixGlobals () {
    string defaultv = globals["default"]:"";
    string first = "";

    y2milestone ("fixing default section");

    // nothing to do if default is empty
    if (defaultv == "")
	return;

    // does default section exist?
    boolean exists = false;
    foreach (map<string,any> s, sections, {
	string label = s["name"]:"";
	if (label == defaultv)
	    exists = true;
	if (first == "")
	    first = label;
    });

    if (exists &&
	(! Mode::update() || globals["former_default_image_flavor"]:nil == nil))
	return;

    // need to fix "default"
    boolean old_entry_found = false;
    string found_name = "";
    list<string> fallback_flavors = generic_fallback_flavors;

    if (Mode::update() && globals["former_default_image_flavor"]:nil != nil) {
	fallback_flavors = prepend(fallback_flavors, globals["former_default_image_flavor"]:"");

	// former_default_image_flavor is removed at the end of the update
	globals = remove (globals, "former_default_image_flavor");
    }

    y2milestone ("looking for image flavors %1", fallback_flavors);
    foreach (string flavor, fallback_flavors, {
	if (found_name != "")
	    return;

	foreach (map<string,any> s, sections, {
	    string label = s["name"]:"";
	    if (regexpmatch (s["original_name"]:"", "^linux(-.*)?$") ||
		regexpmatch (s["image"]:"", "^.*-" + flavor + "$") ||
		regexpmatch (s["kernel"]:"", "^.*-" + flavor + "$")) {
		// found, if we have not yet found a match, or the previously
		// found one was for an "old" entry and we now found a "new"
		// one
		if (found_name == "" ||
		    (old_entry_found && regexpmatch (s["original_name"]:"", "^linux$"))) {
		    found_name = label;
		    if (regexpmatch (s["original_name"]:"", "^linux-.*$"))
			old_entry_found = true;
		    else
			old_entry_found = false;
		}
	    }
	});
    });

    if (found_name != "")
	globals["default"] = found_name;
    else
	globals["default"] = first;

    y2milestone ("setting new default section to: %1", globals["default"]:nil);
}


string getLargestSwapPartition () {
    map<string, integer> swap_sizes = getSwapPartitions ();
    list<string> swap_parts = (list<string>)
        maplist (string name, integer size, swap_sizes, ``(name));
    swap_parts = sort (string a, string b, swap_parts,
		       ``(swap_sizes[a]:0 > swap_sizes[b]:0)
		       );
    return swap_parts[0]:"";
}


/**
 * Fix section of lilo-like bootloader
 */
global void FixSections (void() create_sections) {
    list<string> parts = getPartitionList(`parts_old);
    if (partitioning_last_change
	    != Storage::GetTargetChangeTime()
	&& BootCommon::files_edited)
    {
	displayFilesEditedPopup ();
	files_edited_warned = true;
	return;
    }

    // save old sections and propose new ones in global "sections"
    // (the updated list of old sections will become the new section list in
    // the end)
    list<map<string,any> > old_sect_list = sections;

    create_sections ();

    // new_sect is a map with elements containing: "type" -> section
    map<string,map<string,any> > new_sect = listmap (map<string,any> s,
	sections,
    {
	string label = s["name"]:"";
	string type = s["original_name"]:label;
	return $[type: s];
    });

    // remember a list with all the section "types" in the old section list
    // (needed later in this function to find newly created sections)
    list<string> old_section_types = maplist (map<string,any> s, old_sect_list,
    {
	return s["original_name"]:"";
    });

    // in the old list of sections:
    //	- only keep sections that the user created (no "__auto", or false) or
    //	  changed ("__changed") in the UI
    //  - replace unchanged sections with ones we proposed just now (if
    //    available)
    //  - also notify user when devices for a "changed by user" section are
    //    unavailable or would now be proposed differently (and mark section as
    //    "created by user")
    old_sect_list = maplist (map<string,any> s, old_sect_list, {
	string label = s["name"]:"";
	string type = s["original_name"]:label;
	if (! s["__auto"]:false)
	{
	    y2milestone ("Leaving section %1", label);
	    return s;
	}
	else if (! s["__changed"]:false)
	{
	    y2milestone ("Recreating section %1, new is %2",
		label, new_sect[type]:$[]);
	    return new_sect[type]:$[];
	}
	else
	{
	    // section was created by us, then changed by the user:
	    //	- keep it, except if no newly created section of same type can
	    //	  be found (which probably means we have a bug, because
	    //	  "__auto" says we created the old section as well)
	    //  - maybe notify user to check it (and then mark it as a "user
	    //    defined section")
	    y2milestone ("Warning on section %1", label);
	    boolean cont = true;
	    // if "non-standard" section name and a used device is not
	    // available anymore, notify user
	    if (type != "linux" && type != "failsafe"
		&& type != "memtest86" && type != "wildcard")
	    {
		foreach (string n, s["__devs"]:[], {
		    if (! contains (parts, n))
		    {
			cont = false;
		    }
		});
	    }
	    // find section of same type in newly created sections;
	    // if not found (which should not happen, since according to the
	    // "__auto" key we created it) delete this section
	    map<string,any> new_this_section = new_sect[type]:$[];
	    if (new_this_section == $[]) {
		y2warning("Warning, could not find freshly proposed section" +
		    "corresponding to section %1, deleting it",
		    s["name"]:"");
		return $[];
	    }
	    // if the devices for this section and the freshly created one of
	    // the same type are different, notify user
	    list new_devs = toset(new_this_section["__devs"]:[]);
	    list old_devs = toset(s["__devs"]:[]);
	    if (size (new_devs) != size (old_devs))
		cont = false;
	    else
	    {
                foreach (any d, old_devs, ``{
		    if (! contains (new_devs, d))
			cont = false;
                });
	    }
	    // display info popup for this section;
	    // also, next time we come through this function, consider this
	    // section as a section created by the user (and leave it as it is)
	    if (! cont)
	    {
		s["__auto"] = false;
		displayDiskChangePopup (label);
	    }
	    return s;
	}
    });

    // in newly created sections, fix "resume" parameter in append line if
    // necessary
    y2milestone ("Checking for sections using the resume parameter");
    sections = maplist (map<string,any> s, BootCommon::sections, ``{
	string append = s["append"]:"";
	string resume = getKernelParamFromLine (append, "resume");
	if (resume != "" && resume != nil
	    && ! haskey (getSwapPartitions (), resume))
	// points to unexistent swap partition
	{
	    // bnc# 335526 - Installing memtest with lilo screws up installation
	    if (search(s["original_name"]:"", "memtest") == nil)
	    {
	    	append = setKernelParamToLine (append, "resume", BootCommon::Dev2MountByDev(getLargestSwapPartition ()));
	    	s["append"] = append;
	    }
	}
	return s;
    });

    // now add sections from newly created ones that were unknown before in the
    // old section list, if not already removed by the user (#170469)
    foreach (map<string,any> s, sections, {
	string label = s["name"]:"";
	string type = s["original_name"]:label;
	if (! contains (old_section_types, type) &&
	    ! contains (removed_sections, type))
	{
	    y2milestone ("Adding new section \"%1\": %2",
		label, s);
	    old_sect_list = add(old_sect_list, s);
	    return s;
	}
    });

    // Strange (I must have misread the code here):
    // if a newly created section uses one or more deleted devices, and a
    // section of that type does not exist anymore in the old section list, add
    // it to the old section list
    y2milestone ("Checking for sections needing some of %1", del_parts);
    list<string> to_remove = [];
    foreach (map<string,any> s, sections, {
	list<string> devs = s["__devs"]:[];
	string label = s["name"]:"";
	y2milestone ("Section %1 needs %2", label, devs);
	boolean to_add = false;
	foreach (string d, devs, {
	   if (contains (del_parts, d))
	    {
		to_add = true;
	    }
	});
	if (to_add)
	{
	    map old_sect = listmap (map<string,any> os, old_sect_list, {
		return $[label: os];
	    });

	    if (label != "" && ! haskey(old_sect, label))
	    {
		y2milestone ("Adding %1", s);
		to_remove = add (to_remove, label);
		old_sect_list = add (old_sect_list, s);
	    }
	}
    });

    // FIXME: BUG: looks like a bug to remove a list of labels from the list of
    // deleted devices
    del_parts = (list<string>)difflist (del_parts, to_remove);

    // cleanup: throw away empty sections
    old_sect_list = filter (map<string,any> s, old_sect_list, {
	return s != $[];
    });

    // save old, updated section list as proposed section list
    sections = old_sect_list;
}

/** bnc#474039 upgrade from sles10sp2 to sles11 xen has incorrect default boot option
 * Update in section old devices to new kernel format
 * @param section section to modify
 */
map<string,any> UpdateDeviceForSection(map<string,any> section) {
  if (section["type"]:"" == "image" || section["type"]:"" == "xen")
  {
     //check if we update correct image and if update is needed
     if (BootCommon::UpdateDevice(section["root"]:"nonexisted")
        == BootCommon::RootPartitionDevice
        && section["root"]:""!=(BootCommon::UpdateDevice(section["root"]:"")))
     {
	y2milestone ("Updating device of section %1", section["name"]:"name");
        section["root"]= BootCommon::UpdateDevice(section["root"]:"");
        string resume
	    = BootCommon::getKernelParamFromLine (
                section["append"]:"", "resume");
	if (resume != "false")
	{
	  y2milestone ("Updating resume device of section %1", section["name"]:"name");
	  resume = BootCommon::UpdateDevice (resume);
	  section["append"] = BootCommon::setKernelParamToLine (
	    section["append"]:"", "resume", BootCommon::Dev2MountByDev(resume));
	}
        section["__modified"] = "1";
     }
  }

  return section;
}

/** bnc#474039 upgrade from sles10sp2 to sles11 xen has incorrect default boot option
 * Update sections of bootloader menu (removes obsolete thinks and
 * place for ugly hacks (but doesn't efect zypper dup))
 * modifies internal structures
 * label update is done in perl-Bootloader during updating kernel
 * Purpose is don't break anything, but expect that previous state is
 * working
 */
global void UpdateSections ()
{
  BootCommon::sections = maplist(map<string,any> section, BootCommon::sections, {
    //remap device names from hd* to sd*
    return UpdateDeviceForSection(section);
  });
}


/**
 * Update global options of bootloader
 * modifies internal sreuctures
 */
global void UpdateGlobals () {
    if (BootCommon::globals["timeout"]:"" == "")
        BootCommon::globals["timeout"] = "8";
    list<string> s1_devs
	= splitstring (BootCommon::globals["stage1_dev"]:"", ",");
    s1_devs = maplist (string d, s1_devs, {
	return UpdateDevice (d);
    });
    BootCommon::globals["stage1_dev"] = mergestring (s1_devs, ",");

    // bnc #380509 if autoyast profile includes gfxmenu == none
    // it will be deleted
    if (BootCommon::globals["gfxmenu"]:"" != "none")
        BootCommon::globals["gfxmenu"] = "/boot/message";

    // now that the label for the "linux" section is not "linux" anymore, but
    // some product dependent string that can change with an update ("SLES_10"
    // -> "SLES_10_SP1"), we need to update the label in the "default" line for
    // LILO and GRUB (although the latter only needs it to correctly transform
    // back to the section number)
    // FIXME: is this needed/wanted for ELILO as well?
    if ( contains (["lilo", "grub"], getLoaderType (false)))
	FixGlobals ();
}

/**
 * Update the device map according to changed device names
 * Read device map and store it in internal structures
 */
global void UpdateDeviceMap () {
    device_mapping = mapmap (string unix, string fw, device_mapping, {
	y2milestone ("Updating device in devmap entry %1 -> %2",
	    unix, fw);
	unix = BootCommon::UpdateDevice (unix);
	return $[ unix : fw ];
    });
    y2milestone ("Updated device map: %1", device_mapping);
}

/**
 * Filter sections, remove those pointing to unexistent image
 * @param path_prefix string prefix to be added to kernel path
 * @param relative_path_prefix prefix to be added to relative kernel
 *  paths (without leading slash)
 */
global void RemoveUnexistentSections (string path_prefix,
    string relative_path_prefix)
{
    string defaultv = globals["default"]:"";
    string first = nil;
    BootCommon::sections = filter (map<string,any> s, BootCommon::sections, {
	string label = s["name"]:"";

	// do not touch the wildcard section
	if (regexpmatch (s["image"]:"", ".+\\-\\*"))
	{
	    if (first == nil)
		first = label;
	    return true;
	}

	string type = s["original_name"]:"";
        if (label == "")
	{
	    y2warning ("Removing section with empty title");
	    if (label == defaultv)
		defaultv = nil;
	    return false;
	}
	// FIXME the following check makes sense for all sections`
	if (! contains (["linux", "failsafe", "memtest86", "xen"], type))
	{
	    if (first == nil)
		first = label;
	    return true;
	}
	string kernel = s["image"]:"";
	if (kernel == "")
	{
	    if (first == nil)
		first = label;
	    return true;
	}
	if (substring (kernel, 0, 1) == "/")
	{
	    kernel = path_prefix + kernel;
	}
	else
	{
	    if (relative_path_prefix == "")
		return true;
	    kernel = relative_path_prefix + kernel;
	}
	if (SCR::Read (.target.size, kernel) == -1)
	{
	    y2warning ("Removing section %1 with unexistent kernel %2",
		label, kernel);
	    if (label == defaultv)
		defaultv = nil;
	    return false;
	}
	if (first == nil)
	    first = label;
	return true;
    });
    if (defaultv == nil)
	defaultv = first;
    globals["default"] = defaultv;
}

/**
 * Remove or add initrd option if needed, update append option if some
 *  parameters were changed
 */
global void UpdateInitrdLine () {
    sections = maplist (map<string,any> s, sections, {
        string initrd = s["initrd"]:"";
	string title = s["name"]:"";
	string type = s["original_name"]:"";

	// do not touch the wildcard section
	if (regexpmatch (s["initrd"]:"", ".+\\-\\*"))
	{
	    return s;
	}

        if ((type == "linux" || type == "failsafe")
	    && write_settings["insert_initrd"]:false)
        {
	    s["initrd"] = BootArch::InitrdImage ();
        }
	else if (type == "xen" && write_settings["insert_initrd"]:false)
	{
	   // bnc #400526 there is not xenpae any more...
	   s["initrd"] = "/boot/initrd-xen";
	}
        if (initrd != "")
        {
	    // check for initrd in GRUB format, keep them
	    // FIXME change the check for leading slash
	    if (getLoaderType (false) == "grub"
		&& substring (initrd, 0, 1) == "(")
	    {
		return s;
	    }
	    if (-1 == SCR::Read (.target.size, initrd) && haskey (s, "initrd"))
		s = remove (s, "initrd");
        }
	return s;
    });
}

/**
  * Update append option if some parameters were changed
  */
global void UpdateAppend () {
    sections = maplist (map<string,any> s, sections, {
	string type = s["original_name"]:"";
        if ((type == "linux" || type == "wildcard" || type == "global")
	    && s["append"]:nil != nil
	    && Stage::initial ())
	{
	    s["append"] = UpdateKernelParams (s["append"]:"");
	}
        return s;
    });
    if (haskey (globals, "append"))
    {
	globals["append"] = UpdateKernelParams (globals["append"]:"");
    }
}

/**
 * Update the gfxboot/message/... line if exists
 */
global void UpdateGfxMenu () {
    string message = globals["gfxmenu"]:"";
    if ((message != "") && (search(message, "(") == nil))
    {
	if (-1 == SCR::Read (.target.size, message))
	{
	    globals = remove (globals, "gfxmenu");
	}
    }

}


/*** helper functions for ProposeDeviceMap: ***/
/**
 * Returns true if any device from list devices is in device_mapping
 * marked as hd0.
 */
boolean isHd0(list<string> devices)
{
    boolean ret = false;

    foreach (string value, devices,
        {
            if (device_mapping[value]:"" == "hd0"){
                ret = true;
            }
        });

    return ret;
}

/**
 * Returns first key from mapping associated with value.
 * Example:
 *      map = $[ "a" : "1",
 *               "b" : "2",
 *               "c" : "3",
 *               "d" : "2"];
 *      getDeviceFromMapping("1", map) -> "a"
 *      getDeviceFromMapping("2", map) -> "b"
 */
string getKey(string value, map<string, string> mapping)
{
    string ret = "";

    foreach (string key, string val, mapping,
        {
            if (value == val){
                ret = key;
                return;
            }
        });

    return ret;
}

/**
 * This function changes order of devices in device_mapping.
 * All devices listed in bad_devices are maped to "hdN" are moved to the end
 * (with changed number N). And second step is putting device with boot partition
 * on top (i.e. device_mapping[dev_with_boot] = "hd0").
 *
 * Example:
 *      device_mapping = $[ "/dev/sda" : "hd0",
 *                          "/dev/sdb" : "hd1",
 *                          "/dev/sdc" : "hd2",
 *                          "/dev/sdd" : "hd3",
 *                          "/dev/sde" : "hd4" ];
 *      bad_devices = [ "/dev/sda", "/dev/sdc" ];
 *
 *      changeOrderInDeviceMapping(bad_devices);
 *      // after call, device_mapping is:
 *      device_mapping -> $[ "/dev/sda" : "hd3",
 *                           "/dev/sdb" : "hd0",
 *                           "/dev/sdc" : "hd4",
 *                           "/dev/sdd" : "hd1",
 *                           "/dev/sde" : "hd2" ];
 */
void changeOrderInDeviceMapping(list<string> bad_devices)
{
    integer cur_id = 0;
    list keys = [];
    string value = "";
    string tmp = "";
    string tmp2 = "";

    // get keys from device_mapping, it's not possible to use foreach over keys and values
    // of device_mapping directly, because during the loop device_mapping is changing.
    foreach (string key, string value, device_mapping, { keys = add(keys, key); });

    // put bad_devices at bottom
    foreach (string key, (list<string>)keys,
        {
                value = device_mapping[key]:"";

                // if device is mapped on hdX and this device is _not_ in bad_devices
                if (substring(value, 0, 2) == "hd"
                    && !contains(bad_devices, key)){
                        // get device name of mapped on "hd"+cur_id
                        tmp = getKey("hd" + tostring(cur_id), device_mapping);

                        // swap tmp and key devices (swap their mapping)
                        device_mapping[tmp] = value;
                        device_mapping[key] = "hd" + tostring(cur_id);

                        cur_id = cur_id + 1;
                }
        });

    // put device with boot partition on the top:
    /*
    tmp = (regexptokenize(BootCommon::BootPartitionDevice, "([a-z/]+)[0-9]*"))[0]:"";
    if (haskey(device_mapping, tmp) && device_mapping[tmp]:"" != "hd0"){
        y2debug("Putting device with boot partition (%1) on the top.", tmp);

        tmp2 = getKey("hd0", device_mapping);
        device_mapping[tmp2] = device_mapping[tmp]:"";
        device_mapping[tmp] = "hd0";
    }*/
}
/**
 * Check if MD raid is build on disks not on paritions
 * @param devices - list of devices from MD raid
 * @param tm - unfiltered target map
 * @return - true if MD RAID is build on disks (not on partitions) 
 */

boolean checkMDRaidDevices(list<string> devices, map<string,map> tm)
{
    boolean ret = true;
    foreach (string key, devices, {
	if (key != "" && ret)
	{
	    if (tm[key]:nil != nil)
		ret = true;
	    else
		ret = false;
	}
    });
    return ret;
}

/** bnc#568837 wrong data in device map
 * Function check if disk is in list of devices
 * @param string disk
 * @param list<string> list of devices
 * @return true if success
 */

boolean isDiskInList (string disk, list<string> devices)
{
    boolean ret = false;
    foreach(string dev, devices,
    {
	if (dev == disk)
	{
	   ret = true;
	   break;
	}
    });
    return ret;
}

/** bnc#568837 wrong data in device map
 * Check if disk is in MDRaid it means completed disk is used in RAID
 * @param disk (/dev/sda)
 * @param tm - target map
 * @return - true if disk (not only part of disk) is in MDRAID  
 */
boolean isDiskInMDRaid (string disk, map<string,map> tm) 
{
    boolean ret = false;
    foreach( string dev, map d_info, tm,
    {
	if (d_info["type"]:nil == `CT_MDPART)
	    ret = isDiskInList(disk, d_info["devices"]:[]);
	if (ret)
	    break;
    });
    return ret;
}

/*** helper functions END ***/

/**
 * Generate device map proposal, store it in internal variables.
 *
 * FATE #302075:
 *   When user is installing from USB media or any non IDE disk or bios simply
 *   set any non IDE disk as first and user is not installing on this removable
 *   (non IDE) disk, the order of disks proposed by bios must be changed because
 *   of future remove of USB disk.
 *   This function must find right place for bootloader (which is most probably
 *   boot sector of boot partition (where /boot dir is located)) and change the
 *   order of disks in device map.
 *   This method is only heuristic because order of disks after remove of usb
 *   disk can't be determined by any method.
 *
 *   Algorithm for solving problem with usb disk propsed by bios as hd0:
 *      if usbDiskDevice == hd0 && BootDevice != usbDiskDevice:
 *          change order of disks in device_mappings to have BootDevice as hd0
 */
// FIXME: remove that function from here, as it is grub only
// NOTE: there is a local copy in routines/grub/misc.ycp now
global void ProposeDeviceMap () {
    list<string> usb_disks = []; // contains those usb removable disks

    device_mapping = $[];
    multipath_mapping = $[];
    map<string,map> targetMap = $[];
    if (Mode::config ())
	y2milestone ("Skipping device map proposing in Config mode");
    else
	targetMap = (map<string,map>)Storage::GetTargetMap();

    // filter out non-disk devices
    targetMap = filter (string k, map v, targetMap, {
	return v["type"]:`CT_UNKNOWN==`CT_DMRAID || v["type"]:`CT_UNKNOWN==`CT_DISK
	    || v["type"]:`CT_UNKNOWN==`CT_DMMULTIPATH || 
	      (v["type"]:`CT_UNKNOWN==`CT_MDPART && checkMDRaidDevices(v["devices"]:[], targetMap));
    });

    // bnc#568837 wrong data in device map
    // filter out members of BIOS RAIDs and multipath devices
    targetMap = filter (string k, map v, targetMap, {
	 return v["used_by_type"]:nil != `UB_DMRAID && v["used_by_type"]:nil != `UB_DMMULTIPATH&& 
		((v["used_by_type"]:nil == `UB_MDPART) ? (!isDiskInMDRaid(k,targetMap)):true);
    });

    y2milestone ("Target map: %1", targetMap);

    // add devices with known bios_id
    // collect BIOS IDs which are used
    map ids = $[];
    foreach (string target_dev, map target, targetMap, {
        string bios_id = target["bios_id"]:"";
        if (bios_id != "")
        {
            integer index = tointeger (bios_id) - tointeger ("0x80");
            string grub_dev = sformat ("hd%1", index);
	    // FATE #303548 - doesn't add disk with same bios_id with different name (multipath machine)
	    if (! ids[index]:false)
            {
	    	device_mapping[target_dev] = grub_dev;
            	ids[index] = true;
	    }
        }
    });
    // and guess other devices
    // don't use already used BIOS IDs
    foreach (string target_dev, map target, targetMap, {
        string bios_id = target["bios_id"]:"";
        if (bios_id == "")
        {
            integer index = 0;
            while (ids[index]:false)
                index = index + 1;
            string grub_dev = sformat ("hd%1", index);
	    device_mapping[target_dev] = grub_dev;
            ids[index] = true;
        }
    });

    // Fill usb_disks list with usb removable devices.
    //
    // It's not easy to determine how to identify removable usb devices. Now
    // it tests if driver of device is usb-storage. If you find better
    // algorithm how to find removable usb devices, put it here into foreach
    // to apply this algorithm on all devices.
    foreach (string target_dev, map target, targetMap,
        {
            string driver = target["driver"]:"";
            if (driver == "usb-storage"){
                usb_disks = add(usb_disks, target_dev);
            }
        });
    y2milestone("Found usb discs: %1", usb_disks);
    
    // change order in device_mapping if usb disk is hd0
    // (FATE #302075)
    if (isHd0(usb_disks)
        && BootCommon::BootPartitionDevice != getKey("hd0", device_mapping)){
	y2milestone ("Detected device mapping: %1", device_mapping);
        y2milestone("Changing order in device mapping needed...");
        changeOrderInDeviceMapping(usb_disks);
    }

    if (size(device_mapping) == 1)
	bois_id_missing = false;
    if (StorageDevices::FloppyPresent())
	device_mapping[StorageDevices::FloppyDevice()] = "fd0";

    y2milestone ("Detected device mapping: %1", device_mapping);

    multipath_mapping = BootCommon::mapRealDevicesToMultipath();

    y2milestone ("Detected multipath mapping: %1", multipath_mapping);
}

/**
 * Get the order of disks according to BIOS mapping
 * @return a list of all disks in the order BIOS sees them
 */
global list<string> DisksOrder () {
    if (device_mapping == nil || size (device_mapping) == 0)
    {
	ProposeDeviceMap ();
    }
    map<string,string> devmap_rev = mapmap (string k, string v,
	BootCommon::device_mapping,
    {
	return $[ v : k ];
    });
    devmap_rev = filter (string k, string v, devmap_rev, {
	return substring (k, 0, 2) == "hd";
    });
    list<string> order = maplist (string k, string v, devmap_rev, {
	return v;
    });
    return order;
}

/**
 * Get the summary of disks order for the proposal
 * @return string a line for the summary (or nil if not intended to be shown)
 */
global string DiskOrderSummary () {
    list<string> order = DisksOrder ();
    string ret = nil;
    if (size (order) > 1)
    {
	ret = sformat (
	    // part of summary, %1 is a list of hard disks device names
	    _("Order of Hard Disks: %1"),
	    mergestring (order, ", "));
    }
    return ret;
}

/**
 * Convert XEN boot section to normal linux section
 * if intalling in domU (bnc #436899)
 *
 * @return boolean true if XEN section is converted to linux section
 */

boolean ConvertXENinDomU ()
{

	boolean ret = false;
	if (!Arch::is_xenU())
	{
		y2milestone("Don't convert XEN section - it is not running in domU");
		return ret;
	}

	// tmp sections
	list<map<string,any> > tmp_sections = [];

	foreach(map<string,any> sec, BootCommon::sections,
	{
		if (sec["type"]:"" != "xen")
		{
			tmp_sections = add(tmp_sections, sec);

		} else {
			// convert XEN section to linux section
			y2milestone("Converting XEN section in domU: %1", sec);
			sec["type"] = "image";
			sec["original_name"] = "linux";
			if (haskey(sec,"xen"))
				sec = remove(sec, "xen");
			if (haskey(sec,"xen_append"))
				sec = remove(sec, "xen_append");
			if (haskey(sec,"lines_cache_id"))
				sec = remove(sec, "lines_cache_id");

			y2milestone("Converted XEN section in domU: %1", sec);

			tmp_sections = add(tmp_sections, sec);

			ret = true;
		}
	});
	
	BootCommon::sections = tmp_sections;
	return ret;
}



} // EOF

/*
 * Local variables:
 *     mode: ycp
 *     mode: font-lock
 *     mode: auto-fill
 *     indent-level: 4
 *     fill-column: 78
 * End:
 */
